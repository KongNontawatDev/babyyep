"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/nuka-carousel";
exports.ids = ["vendor-chunks/nuka-carousel"];
exports.modules = {

/***/ "(ssr)/./node_modules/nuka-carousel/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/nuka-carousel/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Alignment: () => (/* binding */ Alignment),\n/* harmony export */   Directions: () => (/* binding */ Directions),\n/* harmony export */   NextButton: () => (/* binding */ NextButton),\n/* harmony export */   PagingDots: () => (/* binding */ PagingDots),\n/* harmony export */   Positions: () => (/* binding */ Positions),\n/* harmony export */   PreviousButton: () => (/* binding */ PreviousButton),\n/* harmony export */   ScrollMode: () => (/* binding */ ScrollMode),\n/* harmony export */   \"default\": () => (/* binding */ Carousel)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __pow = Math.pow;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// src/carousel.tsx\n\n\n// src/slide.tsx\n\n\n// src/hooks/use-slide-intersection-observer.ts\n\nvar useSlideIntersectionObserver = (elementRef, rootRef, callback) => {\n  const [entry, setEntry] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  const callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    callbackRef.current = callback;\n  }, [callback]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const node = elementRef == null ? void 0 : elementRef.current;\n    const root = rootRef == null ? void 0 : rootRef.current;\n    if (!window.IntersectionObserver || !node || !root)\n      return;\n    const observer = new IntersectionObserver(\n      (entries) => {\n        entries.forEach((entry2) => {\n          setEntry(entry2);\n          callbackRef.current(entry2);\n        });\n      },\n      {\n        threshold: [0.05, 0.95],\n        root\n      }\n    );\n    observer.observe(node);\n    return () => observer.disconnect();\n  }, [elementRef, rootRef]);\n  return entry;\n};\n\n// src/slide.tsx\n\nvar getSlideWidth = (count, wrapAround) => `${wrapAround ? 100 / (3 * count) : 100 / count}%`;\nvar getSlideStyles = (count, isCurrentSlide, isVisibleSlide, wrapAround, cellSpacing, animation, speed, zoomScale, adaptiveHeight, initializedAdaptiveHeight, slideWidth) => {\n  const width = slideWidth != null ? slideWidth : getSlideWidth(count, wrapAround);\n  const visibleSlideOpacity = isVisibleSlide ? 1 : 0;\n  const animationSpeed = animation === \"fade\" ? 200 : 500;\n  let height = \"auto\";\n  if (adaptiveHeight) {\n    if (initializedAdaptiveHeight) {\n      height = \"100%\";\n    } else if (isVisibleSlide) {\n      height = \"auto\";\n    } else {\n      height = \"0\";\n    }\n  }\n  return {\n    width,\n    height,\n    padding: `0 ${cellSpacing ? cellSpacing / 2 : 0}px`,\n    transition: animation ? `${speed || animationSpeed}ms ease 0s` : void 0,\n    transform: animation === \"zoom\" ? `scale(${isCurrentSlide && isVisibleSlide ? 1 : zoomScale || 0.85})` : void 0,\n    opacity: animation === \"fade\" ? visibleSlideOpacity : 1\n  };\n};\nvar generateIndex = (index, count, typeOfSlide) => {\n  if (typeOfSlide === \"prev-cloned\") {\n    return index - count;\n  }\n  if (typeOfSlide === \"next-cloned\") {\n    return index + count;\n  }\n  return index;\n};\nvar Slide = ({\n  count,\n  children,\n  index,\n  isCurrentSlide,\n  typeOfSlide,\n  wrapAround,\n  cellSpacing,\n  slideWidth,\n  animation,\n  speed,\n  zoomScale,\n  onVisibleSlideHeightChange,\n  adaptiveHeight,\n  initializedAdaptiveHeight,\n  updateIOEntry,\n  id,\n  carouselRef,\n  carouselId,\n  tabbed\n}) => {\n  var _a;\n  const customIndex = wrapAround ? generateIndex(index, count, typeOfSlide) : index;\n  const slideRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const entry = useSlideIntersectionObserver(slideRef, carouselRef, (entry2) => {\n    updateIOEntry(id, (entry2 == null ? void 0 : entry2.intersectionRatio) >= 0.95);\n  });\n  const isVisible = !!(entry == null ? void 0 : entry.isIntersecting);\n  const isFullyVisible = ((_a = entry == null ? void 0 : entry.intersectionRatio) != null ? _a : 1) >= 0.95;\n  const prevIsVisibleRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    var _a2;\n    const node = slideRef.current;\n    if (node) {\n      const slideHeight = (_a2 = node.getBoundingClientRect()) == null ? void 0 : _a2.height;\n      const prevIsVisible = prevIsVisibleRef.current;\n      if (isVisible && !prevIsVisible) {\n        onVisibleSlideHeightChange(customIndex, slideHeight);\n      } else if (!isVisible && prevIsVisible) {\n        onVisibleSlideHeightChange(customIndex, null);\n      }\n      prevIsVisibleRef.current = isVisible;\n    }\n  }, [customIndex, isVisible, onVisibleSlideHeightChange]);\n  const currentSlideClass = isCurrentSlide && isFullyVisible ? \" slide-current\" : \"\";\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    \"div\",\n    __spreadProps(__spreadValues({\n      ref: slideRef\n    }, { inert: isFullyVisible ? void 0 : \"true\" }), {\n      className: `slide${currentSlideClass}${typeOfSlide ? ` ${typeOfSlide}` : \"\"}${isFullyVisible ? \" slide-visible\" : \"\"}`,\n      style: getSlideStyles(\n        count,\n        isCurrentSlide,\n        isFullyVisible,\n        wrapAround,\n        cellSpacing,\n        animation,\n        speed,\n        zoomScale,\n        adaptiveHeight,\n        initializedAdaptiveHeight,\n        slideWidth\n      ),\n      id: typeOfSlide ? void 0 : `${carouselId}-slide-${index + 1}`,\n      role: tabbed ? \"tabpanel\" : \"group\",\n      \"aria-roledescription\": tabbed ? void 0 : \"slide\",\n      children\n    })\n  );\n};\nvar slide_default = Slide;\n\n// src/announce-slide.tsx\n\nvar styles = {\n  position: \"absolute\",\n  width: \"1px\",\n  height: \"1px\",\n  overflow: \"hidden\",\n  padding: 0,\n  margin: \"-1px\",\n  clip: \"rect(0, 0, 0, 0)\",\n  whiteSpace: \"nowrap\",\n  border: 0\n};\nvar AnnounceSlide = ({\n  message,\n  ariaLive = \"polite\"\n}) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { \"aria-live\": ariaLive, \"aria-atomic\": \"true\", style: styles, tabIndex: -1, children: message });\nvar defaultRenderAnnounceSlideMessage = ({\n  currentSlide,\n  count\n}) => `Slide ${currentSlide + 1} of ${count}`;\nvar announce_slide_default = AnnounceSlide;\n\n// src/slider-list.tsx\n\n\n// src/default-controls.tsx\n\n\n// src/types.ts\nvar Alignment = /* @__PURE__ */ ((Alignment2) => {\n  Alignment2[\"Center\"] = \"center\";\n  Alignment2[\"Right\"] = \"right\";\n  Alignment2[\"Left\"] = \"left\";\n  return Alignment2;\n})(Alignment || {});\nvar Directions = /* @__PURE__ */ ((Directions2) => {\n  Directions2[\"Next\"] = \"next\";\n  Directions2[\"Prev\"] = \"prev\";\n  Directions2[\"Up\"] = \"up\";\n  Directions2[\"Down\"] = \"down\";\n  return Directions2;\n})(Directions || {});\nvar Positions = /* @__PURE__ */ ((Positions2) => {\n  Positions2[\"TopLeft\"] = \"TopLeft\";\n  Positions2[\"TopCenter\"] = \"TopCenter\";\n  Positions2[\"TopRight\"] = \"TopRight\";\n  Positions2[\"CenterLeft\"] = \"CenterLeft\";\n  Positions2[\"CenterCenter\"] = \"CenterCenter\";\n  Positions2[\"CenterRight\"] = \"CenterRight\";\n  Positions2[\"BottomLeft\"] = \"BottomLeft\";\n  Positions2[\"BottomCenter\"] = \"BottomCenter\";\n  Positions2[\"BottomRight\"] = \"BottomRight\";\n  return Positions2;\n})(Positions || {});\nvar ScrollMode = /* @__PURE__ */ ((ScrollMode2) => {\n  ScrollMode2[\"page\"] = \"page\";\n  ScrollMode2[\"remainder\"] = \"remainder\";\n  return ScrollMode2;\n})(ScrollMode || {});\n\n// src/utils.ts\nvar getNextMoveIndex = (scrollMode, wrapAround, currentSlide, slideCount, slidesToScroll, slidesToShow, cellAlign) => {\n  if (wrapAround) {\n    return currentSlide + slidesToScroll;\n  }\n  if (currentSlide >= slideCount - 1 || cellAlign === \"left\" && currentSlide >= slideCount - slidesToShow) {\n    return currentSlide;\n  }\n  if (scrollMode === \"remainder\" /* remainder */ && cellAlign === \"left\") {\n    return Math.min(currentSlide + slidesToScroll, slideCount - slidesToShow);\n  }\n  return Math.min(currentSlide + slidesToScroll, slideCount - 1);\n};\nvar getPrevMoveIndex = (scrollMode, wrapAround, currentSlide, slidesToScroll, slidesToShow, cellAlign) => {\n  if (wrapAround) {\n    return currentSlide - slidesToScroll;\n  }\n  if (currentSlide <= 0 || cellAlign === \"right\" && currentSlide <= slidesToShow - 1) {\n    return currentSlide;\n  }\n  if (scrollMode === \"remainder\" /* remainder */ && cellAlign === \"right\") {\n    return Math.max(currentSlide - slidesToScroll, slidesToShow - 1);\n  }\n  return Math.max(currentSlide - slidesToScroll, 0);\n};\nvar getDefaultSlideIndex = (slideIndex, slideCount, slidesToShow, slidesToScroll, cellAlign, autoplayReverse, scrollMode) => {\n  if (slideIndex !== void 0) {\n    return slideIndex;\n  }\n  const dotIndexes = getDotIndexes(\n    slideCount,\n    slidesToScroll,\n    scrollMode,\n    slidesToShow,\n    false,\n    cellAlign\n  );\n  return autoplayReverse ? dotIndexes[dotIndexes.length - 1] : dotIndexes[0];\n};\nvar getBoundedIndex = (rawIndex, slideCount) => {\n  return (rawIndex % slideCount + slideCount) % slideCount;\n};\n\n// src/default-controls.tsx\n\nvar defaultButtonStyles = (disabled) => ({\n  border: 0,\n  background: \"rgba(0,0,0,0.4)\",\n  color: \"white\",\n  padding: 10,\n  textTransform: \"uppercase\",\n  opacity: disabled ? 0.3 : 1,\n  cursor: disabled ? \"not-allowed\" : \"pointer\"\n});\nvar prevButtonDisabled = ({\n  cellAlign,\n  currentSlide,\n  slidesToShow,\n  wrapAround\n}) => {\n  if (wrapAround) {\n    return false;\n  }\n  if (currentSlide === 0) {\n    return true;\n  }\n  if (cellAlign === \"right\" && currentSlide <= slidesToShow - 1) {\n    return true;\n  }\n  return false;\n};\nvar PreviousButton = ({\n  previousSlide,\n  defaultControlsConfig: {\n    prevButtonClassName,\n    prevButtonStyle = {},\n    prevButtonText,\n    prevButtonOnClick\n  },\n  onUserNavigation,\n  carouselId,\n  previousDisabled: disabled\n}) => {\n  const handleClick = (event) => {\n    prevButtonOnClick == null ? void 0 : prevButtonOnClick(event);\n    if (event.defaultPrevented)\n      return;\n    onUserNavigation(event);\n    event.preventDefault();\n    previousSlide();\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    \"button\",\n    {\n      className: prevButtonClassName,\n      style: __spreadValues(__spreadValues({}, defaultButtonStyles(disabled)), prevButtonStyle),\n      disabled,\n      onClick: handleClick,\n      \"aria-label\": \"previous\",\n      \"aria-controls\": `${carouselId}-slider-frame`,\n      type: \"button\",\n      children: prevButtonText || \"Prev\"\n    }\n  );\n};\nvar nextButtonDisabled = ({\n  cellAlign,\n  currentSlide,\n  slideCount,\n  slidesToShow,\n  wrapAround\n}) => {\n  if (wrapAround) {\n    return false;\n  }\n  if (currentSlide >= slideCount - 1) {\n    return true;\n  }\n  if (cellAlign === \"left\" && currentSlide >= slideCount - slidesToShow) {\n    return true;\n  }\n  return false;\n};\nvar NextButton = ({\n  nextSlide,\n  defaultControlsConfig: {\n    nextButtonClassName,\n    nextButtonStyle = {},\n    nextButtonText,\n    nextButtonOnClick\n  },\n  carouselId,\n  nextDisabled: disabled,\n  onUserNavigation\n}) => {\n  const handleClick = (event) => {\n    nextButtonOnClick == null ? void 0 : nextButtonOnClick(event);\n    if (event.defaultPrevented)\n      return;\n    onUserNavigation(event);\n    event.preventDefault();\n    nextSlide();\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    \"button\",\n    {\n      className: nextButtonClassName,\n      style: __spreadValues(__spreadValues({}, defaultButtonStyles(disabled)), nextButtonStyle),\n      disabled,\n      onClick: handleClick,\n      \"aria-label\": \"next\",\n      \"aria-controls\": `${carouselId}-slider-frame`,\n      type: \"button\",\n      children: nextButtonText || \"Next\"\n    }\n  );\n};\nvar getDotIndexes = (slideCount, slidesToScroll, scrollMode, slidesToShow, wrapAround, cellAlign) => {\n  const dotIndexes = [];\n  const scrollSlides = slidesToScroll <= 0 ? 1 : slidesToScroll;\n  if (wrapAround) {\n    for (let i = 0; i < slideCount; i += scrollSlides) {\n      dotIndexes.push(i);\n    }\n    return dotIndexes;\n  }\n  if (cellAlign === \"center\") {\n    for (let i = 0; i < slideCount - 1; i += scrollSlides) {\n      dotIndexes.push(i);\n    }\n    if (slideCount > 0) {\n      dotIndexes.push(slideCount - 1);\n    }\n    return dotIndexes;\n  }\n  if (cellAlign === \"left\") {\n    if (slidesToShow >= slideCount) {\n      return [0];\n    }\n    const lastPossibleIndexWithoutWhitespace = slideCount - slidesToShow;\n    for (let i = 0; i < lastPossibleIndexWithoutWhitespace; i += scrollSlides) {\n      dotIndexes.push(i);\n    }\n    if (scrollMode === \"remainder\" /* remainder */) {\n      dotIndexes.push(lastPossibleIndexWithoutWhitespace);\n    } else {\n      dotIndexes.push(dotIndexes[dotIndexes.length - 1] + scrollSlides);\n    }\n    return dotIndexes;\n  }\n  if (cellAlign === \"right\") {\n    if (slidesToShow >= slideCount) {\n      return [slideCount - 1];\n    }\n    const firstPossibleIndexWithoutWhitespace = slidesToShow - 1;\n    if (scrollMode === \"remainder\" /* remainder */) {\n      for (let i = firstPossibleIndexWithoutWhitespace; i < slideCount - 1; i += scrollSlides) {\n        dotIndexes.push(i);\n      }\n      dotIndexes.push(slideCount - 1);\n    } else {\n      for (let i = slideCount - 1; i > firstPossibleIndexWithoutWhitespace; i -= scrollSlides) {\n        dotIndexes.push(i);\n      }\n      dotIndexes.push(dotIndexes[dotIndexes.length - 1] - scrollSlides);\n      dotIndexes.reverse();\n    }\n    return dotIndexes;\n  }\n  return dotIndexes;\n};\nvar PagingDots = ({\n  pagingDotsIndices,\n  defaultControlsConfig: {\n    pagingDotsContainerClassName,\n    pagingDotsClassName,\n    pagingDotsStyle = {},\n    pagingDotsOnClick\n  },\n  carouselId,\n  currentSlide,\n  onUserNavigation,\n  slideCount,\n  goToSlide,\n  tabbed\n}) => {\n  const listStyles = {\n    position: \"relative\",\n    top: -10,\n    display: \"flex\",\n    margin: 0,\n    padding: 0,\n    listStyleType: \"none\"\n  };\n  const getButtonStyles = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (active) => ({\n      cursor: \"pointer\",\n      opacity: active ? 1 : 0.5,\n      background: \"transparent\",\n      border: \"none\",\n      fill: \"black\"\n    }),\n    []\n  );\n  const currentSlideBounded = getBoundedIndex(currentSlide, slideCount);\n  if (!tabbed)\n    return null;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    \"div\",\n    {\n      className: pagingDotsContainerClassName,\n      style: listStyles,\n      role: \"tablist\",\n      \"aria-label\": \"Choose slide to display.\",\n      children: pagingDotsIndices.map((slideIndex, i) => {\n        const isActive = currentSlideBounded === slideIndex || // sets navigation dots active if the current slide falls in the current index range\n        currentSlideBounded < slideIndex && (i === 0 || currentSlideBounded > pagingDotsIndices[i - 1]);\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          \"button\",\n          {\n            className: [\n              \"paging-item\",\n              pagingDotsClassName,\n              isActive ? \"active\" : null\n            ].join(\" \"),\n            type: \"button\",\n            style: __spreadValues(__spreadValues({}, getButtonStyles(isActive)), pagingDotsStyle),\n            onClick: (event) => {\n              pagingDotsOnClick == null ? void 0 : pagingDotsOnClick(event);\n              if (event.defaultPrevented)\n                return;\n              onUserNavigation(event);\n              goToSlide(slideIndex);\n            },\n            \"aria-label\": `slide ${slideIndex + 1}`,\n            \"aria-selected\": isActive,\n            \"aria-controls\": `${carouselId}-slide-${slideIndex + 1}`,\n            role: \"tab\",\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n              \"svg\",\n              {\n                className: \"paging-dot\",\n                width: \"6\",\n                height: \"6\",\n                \"aria-hidden\": \"true\",\n                focusable: \"false\",\n                viewBox: \"0 0 6 6\",\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"circle\", { cx: \"3\", cy: \"3\", r: \"3\" })\n              }\n            )\n          },\n          slideIndex\n        );\n      })\n    }\n  );\n};\n\n// src/hooks/use-tween.ts\n\nvar useTween = (durationMs, easingFunction, navigationNum, shouldInterrupt) => {\n  const [normalizedTimeRaw, setNormalizedTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n  const startTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(Date.now());\n  const rAF = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  const isFirstRender = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n  const lastNavigationNum = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const normalizedTime = lastNavigationNum.current === null || lastNavigationNum.current === navigationNum || shouldInterrupt ? normalizedTimeRaw : 0;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    lastNavigationNum.current = navigationNum;\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n    if (shouldInterrupt) {\n      return;\n    }\n    startTime.current = Date.now();\n    setNormalizedTime(0);\n    const tick = () => {\n      rAF.current = requestAnimationFrame(() => {\n        const currentTime = Date.now();\n        const normalizedTime2 = Math.min(\n          1,\n          (currentTime - startTime.current) / durationMs\n        );\n        setNormalizedTime(normalizedTime2);\n        if (normalizedTime2 < 1) {\n          tick();\n        } else {\n          rAF.current = void 0;\n        }\n      });\n    };\n    tick();\n    return () => {\n      if (rAF.current !== void 0) {\n        cancelAnimationFrame(rAF.current);\n        setNormalizedTime(1);\n      }\n    };\n  }, [navigationNum, durationMs, shouldInterrupt]);\n  return {\n    isAnimating: normalizedTime !== 1,\n    value: easingFunction(normalizedTime)\n  };\n};\n\n// src/slider-list.tsx\n\nvar getPercentOffsetForSlide = (currentSlide, slideCount, slidesToShow, cellAlign, wrapAround) => {\n  const renderedSlideCount = wrapAround ? 3 * slideCount : slideCount;\n  const singleSlidePercentOfWhole = 100 / renderedSlideCount;\n  let slide0Offset = wrapAround ? -100 / 3 : 0;\n  if (cellAlign === \"right\" && slidesToShow > 1) {\n    const excessSlides = slidesToShow - 1;\n    slide0Offset += singleSlidePercentOfWhole * excessSlides;\n  }\n  if (cellAlign === \"center\" && slidesToShow > 1) {\n    const excessSlides = slidesToShow - 1;\n    const excessLeftSlides = excessSlides / 2;\n    slide0Offset += singleSlidePercentOfWhole * excessLeftSlides;\n  }\n  const currentSlideOffsetFrom0 = 100 / renderedSlideCount * currentSlide;\n  return slide0Offset - currentSlideOffsetFrom0;\n};\nvar SliderList = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  ({\n    animation,\n    animationDistance,\n    cellAlign,\n    children,\n    currentSlide,\n    disableAnimation,\n    disableEdgeSwiping,\n    draggedOffset,\n    easing,\n    edgeEasing,\n    isDragging,\n    scrollMode,\n    slideCount,\n    slidesToScroll,\n    slidesToShow,\n    speed,\n    wrapAround,\n    slideWidth,\n    setIsAnimating\n  }, forwardedRef) => {\n    const renderedSlideCount = wrapAround ? 3 * slideCount : slideCount;\n    const listVisibleWidth = slideWidth ? `calc(${slideWidth} * ${renderedSlideCount})` : `${renderedSlideCount * 100 / slidesToShow}%`;\n    const percentOffsetForSlideProps = [\n      slideCount,\n      slidesToShow,\n      cellAlign,\n      wrapAround\n    ];\n    const dotIndexes = getDotIndexes(\n      slideCount,\n      slidesToScroll,\n      scrollMode,\n      slidesToShow,\n      wrapAround,\n      cellAlign\n    );\n    let clampedDraggedOffset = `${draggedOffset}px`;\n    if (isDragging && disableEdgeSwiping && !wrapAround) {\n      const clampOffsets = [\n        dotIndexes[0],\n        dotIndexes[dotIndexes.length - 1]\n      ].map(\n        (index) => getPercentOffsetForSlide(index, ...percentOffsetForSlideProps)\n      );\n      clampedDraggedOffset = `clamp(${clampOffsets[1]}%, ${draggedOffset}px, ${clampOffsets[0]}%)`;\n    }\n    const slideBasedOffset = getPercentOffsetForSlide(\n      currentSlide,\n      ...percentOffsetForSlideProps\n    );\n    const isEdgeEasing = !disableEdgeSwiping && !wrapAround && (currentSlide === dotIndexes[0] && animationDistance < 0 || currentSlide === dotIndexes[dotIndexes.length - 1] && animationDistance > 0);\n    const { value: transition, isAnimating } = useTween(\n      speed,\n      !isEdgeEasing ? easing : edgeEasing,\n      // animationDistance is assumed to be unique enough that it can be used to\n      // detect when a new animation should start. This is used in addition to\n      // currentSlide because some animations, such as those with edgeEasing, do\n      // not occur due to a change in value of currentSlide\n      currentSlide + animationDistance,\n      isDragging || disableAnimation || animation === \"fade\"\n    );\n    let positioning;\n    if (isDragging || slideBasedOffset !== 0 || isAnimating) {\n      if (isDragging) {\n        positioning = `translateX(${clampedDraggedOffset})`;\n      } else {\n        const transitionOffset = isAnimating ? (1 - transition) * animationDistance : 0;\n        positioning = `translateX(calc(${slideBasedOffset}% - ${transitionOffset}px))`;\n      }\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      setIsAnimating(isAnimating);\n    }, [isAnimating, setIsAnimating]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      \"div\",\n      {\n        ref: forwardedRef,\n        className: \"slider-list\",\n        style: {\n          width: listVisibleWidth,\n          textAlign: \"left\",\n          userSelect: \"auto\",\n          transform: positioning,\n          display: \"flex\"\n        },\n        children\n      }\n    );\n  }\n);\nSliderList.displayName = \"SliderList\";\n\n// src/controls.tsx\n\n\n// src/control-styles.ts\nvar commonStyles = {\n  position: \"absolute\",\n  display: \"flex\",\n  zIndex: 1,\n  top: 0,\n  left: 0,\n  bottom: 0,\n  right: 0\n};\nvar getControlContainerFlexStyles = (pos) => {\n  let alignItems;\n  switch (pos) {\n    case \"TopLeft\" /* TopLeft */:\n    case \"TopCenter\" /* TopCenter */:\n    case \"TopRight\" /* TopRight */:\n      alignItems = \"flex-start\";\n      break;\n    case \"CenterLeft\" /* CenterLeft */:\n    case \"CenterCenter\" /* CenterCenter */:\n    case \"CenterRight\" /* CenterRight */:\n      alignItems = \"center\";\n      break;\n    case \"BottomLeft\" /* BottomLeft */:\n    case \"BottomCenter\" /* BottomCenter */:\n    case \"BottomRight\" /* BottomRight */:\n      alignItems = \"flex-end\";\n      break;\n  }\n  let justifyContent;\n  switch (pos) {\n    case \"TopLeft\" /* TopLeft */:\n    case \"CenterLeft\" /* CenterLeft */:\n    case \"BottomLeft\" /* BottomLeft */:\n      justifyContent = \"flex-start\";\n      break;\n    case \"TopCenter\" /* TopCenter */:\n    case \"CenterCenter\" /* CenterCenter */:\n    case \"BottomCenter\" /* BottomCenter */:\n      justifyContent = \"center\";\n      break;\n    case \"TopRight\" /* TopRight */:\n    case \"CenterRight\" /* CenterRight */:\n    case \"BottomRight\" /* BottomRight */:\n      justifyContent = \"flex-end\";\n      break;\n  }\n  return { alignItems, justifyContent };\n};\nvar getControlContainerStyles = (pos) => {\n  return __spreadValues(__spreadValues({}, getControlContainerFlexStyles(pos)), commonStyles);\n};\n\n// src/controls.tsx\n\nvar controlsMap = [\n  { funcName: \"renderTopLeftControls\", key: \"TopLeft\" /* TopLeft */ },\n  { funcName: \"renderTopCenterControls\", key: \"TopCenter\" /* TopCenter */ },\n  { funcName: \"renderTopRightControls\", key: \"TopRight\" /* TopRight */ },\n  { funcName: \"renderCenterLeftControls\", key: \"CenterLeft\" /* CenterLeft */ },\n  { funcName: \"renderCenterCenterControls\", key: \"CenterCenter\" /* CenterCenter */ },\n  { funcName: \"renderCenterRightControls\", key: \"CenterRight\" /* CenterRight */ },\n  { funcName: \"renderBottomLeftControls\", key: \"BottomLeft\" /* BottomLeft */ },\n  { funcName: \"renderBottomCenterControls\", key: \"BottomCenter\" /* BottomCenter */ },\n  { funcName: \"renderBottomRightControls\", key: \"BottomRight\" /* BottomRight */ }\n];\nvar renderControls = (props, slideCount, currentSlide, goToSlide, nextSlide, prevSlide, slidesToScroll) => {\n  if (props.withoutControls) {\n    return null;\n  }\n  const disableCheckProps = __spreadProps(__spreadValues({}, props), {\n    currentSlide,\n    slideCount\n  });\n  const nextDisabled = nextButtonDisabled(disableCheckProps);\n  const previousDisabled = prevButtonDisabled(disableCheckProps);\n  const pagingDotsIndices = getDotIndexes(\n    slideCount,\n    slidesToScroll,\n    props.scrollMode,\n    props.slidesToShow,\n    props.wrapAround,\n    props.cellAlign\n  );\n  return controlsMap.map((control) => {\n    var _a;\n    if (!props[control.funcName] || typeof props[control.funcName] !== \"function\") {\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}, control.funcName);\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      \"div\",\n      {\n        style: __spreadProps(__spreadValues({}, getControlContainerStyles(control.key)), {\n          pointerEvents: \"none\"\n        }),\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          \"div\",\n          {\n            className: [\n              `slider-control-${control.key.toLowerCase()}`,\n              props.defaultControlsConfig.containerClassName || \"\"\n            ].join(\" \").trim(),\n            style: { pointerEvents: \"auto\" },\n            children: (_a = props[control.funcName]) == null ? void 0 : _a.call(props, {\n              cellAlign: props.cellAlign,\n              cellSpacing: props.cellSpacing,\n              currentSlide,\n              defaultControlsConfig: props.defaultControlsConfig || {},\n              carouselId: props.carouselId,\n              pagingDotsIndices,\n              goToSlide,\n              nextDisabled,\n              nextSlide,\n              onUserNavigation: props.onUserNavigation,\n              previousDisabled,\n              previousSlide: prevSlide,\n              scrollMode: props.scrollMode,\n              slideCount,\n              slidesToScroll,\n              slidesToShow: props.slidesToShow || 1,\n              tabbed: props.tabbed,\n              vertical: props.vertical,\n              wrapAround: props.wrapAround\n            })\n          }\n        )\n      },\n      control.funcName\n    );\n  });\n};\nvar controls_default = renderControls;\n\n// src/default-carousel-props.tsx\n\nvar easeOut = (t) => __pow(t - 1, 3) + 1;\nvar defaultProps = {\n  adaptiveHeight: false,\n  adaptiveHeightAnimation: true,\n  afterSlide: () => {\n  },\n  autoplay: false,\n  autoplayInterval: 3e3,\n  autoplayReverse: false,\n  beforeSlide: () => {\n  },\n  cellAlign: \"left\",\n  cellSpacing: 0,\n  defaultControlsConfig: {},\n  disableAnimation: false,\n  disableEdgeSwiping: false,\n  dragging: true,\n  dragThreshold: 0.5,\n  easing: easeOut,\n  edgeEasing: easeOut,\n  enableKeyboardControls: false,\n  frameAriaLabel: \"Slider\",\n  keyCodeConfig: {\n    nextSlide: [39, 68, 38, 87],\n    previousSlide: [37, 65, 40, 83],\n    firstSlide: [81],\n    lastSlide: [69],\n    pause: [32]\n  },\n  landmark: false,\n  onDragStart: () => {\n  },\n  onDrag: () => {\n  },\n  onDragEnd: () => {\n  },\n  onUserNavigation: () => {\n  },\n  pauseOnHover: true,\n  renderAnnounceSlideMessage: defaultRenderAnnounceSlideMessage,\n  renderBottomCenterControls: (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PagingDots, __spreadValues({}, props)),\n  renderCenterLeftControls: (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreviousButton, __spreadValues({}, props)),\n  renderCenterRightControls: (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NextButton, __spreadValues({}, props)),\n  scrollMode: \"page\" /* page */,\n  slidesToScroll: 1,\n  slidesToShow: 1,\n  speed: 500,\n  style: {},\n  swiping: true,\n  tabbed: true,\n  vertical: false,\n  withoutControls: false,\n  wrapAround: false,\n  children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {})\n};\nvar default_carousel_props_default = defaultProps;\n\n// src/hooks/use-frame-height.ts\n\n\n// src/hooks/use-state-with-ref.ts\n\nvar useStateWithRef = (initialState) => {\n  const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialState);\n  const valueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialState);\n  const setValueAndRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((newValue) => {\n    valueRef.current = newValue;\n    setValue(newValue);\n  }, []);\n  return [value, setValueAndRef, valueRef];\n};\n\n// src/hooks/use-frame-height.ts\nvar useFrameHeight = (adaptiveHeight, slidesToShow, slideCount) => {\n  const [visibleHeights, setVisibleHeights, visibleHeightsRef] = useStateWithRef([]);\n  const [initializedAdaptiveHeight, setInitializedAdaptiveHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const handleVisibleSlideHeightChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (slideIndex, height) => {\n      const latestVisibleHeights = visibleHeightsRef.current;\n      let newVisibleHeights;\n      if (height === null) {\n        newVisibleHeights = latestVisibleHeights.filter(\n          (slideHeight) => slideHeight.slideIndex !== slideIndex\n        );\n      } else {\n        newVisibleHeights = [...latestVisibleHeights, { slideIndex, height }];\n      }\n      setVisibleHeights(newVisibleHeights);\n      if (newVisibleHeights.length >= Math.min(slideCount, Math.ceil(slidesToShow))) {\n        setInitializedAdaptiveHeight(true);\n      }\n    },\n    [slideCount, setVisibleHeights, slidesToShow, visibleHeightsRef]\n  );\n  const frameHeight = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (adaptiveHeight) {\n      if (!initializedAdaptiveHeight) {\n        return \"auto\";\n      }\n      const maxHeight = Math.max(\n        0,\n        ...visibleHeights.map((height) => height.height)\n      );\n      return `${maxHeight}px`;\n    } else {\n      return \"auto\";\n    }\n  }, [adaptiveHeight, initializedAdaptiveHeight, visibleHeights]);\n  return {\n    handleVisibleSlideHeightChange,\n    frameHeight,\n    initializedAdaptiveHeight\n  };\n};\n\n// src/hooks/use-forward-ref.ts\n\nvar useForwardRef = (ref) => {\n  const targetRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!ref)\n      return;\n    if (typeof ref === \"function\") {\n      ref(targetRef.current);\n    } else {\n      ref.current = targetRef.current;\n    }\n  }, [ref]);\n  return targetRef;\n};\n\n// src/carousel.tsx\n\nvar Carousel = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  (rawProps, ref) => {\n    const props = rawProps;\n    const internalCarouselId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const {\n      adaptiveHeight,\n      adaptiveHeightAnimation,\n      afterSlide,\n      animation,\n      autoplay,\n      autoplayInterval,\n      autoplayReverse,\n      beforeSlide,\n      carouselId = internalCarouselId,\n      cellAlign: propsCellAlign,\n      cellSpacing,\n      children,\n      className,\n      disableAnimation,\n      dragging: desktopDraggingEnabled,\n      dragThreshold: propsDragThreshold,\n      enableKeyboardControls,\n      frameAriaLabel,\n      keyCodeConfig,\n      landmark,\n      onDrag,\n      onDragEnd,\n      onDragStart,\n      onUserNavigation,\n      pauseOnHover,\n      renderAnnounceSlideMessage,\n      scrollMode: propsScrollMode,\n      slideIndex,\n      slidesToScroll: propsSlidesToScroll,\n      slidesToShow: propsSlidesToShow,\n      slideWidth,\n      speed,\n      style,\n      swiping: mobileDraggingEnabled,\n      tabbed,\n      wrapAround,\n      zoomScale\n    } = props;\n    const filteredSlides = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(children).filter(Boolean);\n    const slideCount = filteredSlides.length;\n    const cellAlign = slideWidth || propsSlidesToScroll === \"auto\" ? \"left\" : propsCellAlign;\n    const scrollMode = propsSlidesToScroll === \"auto\" ? \"remainder\" /* remainder */ : propsScrollMode;\n    const [slideIOEntries, setSlideIOEntries] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n      /* @__PURE__ */ new Map()\n    );\n    const visibleCount = Array.from(slideIOEntries).filter(\n      ([, visible]) => visible\n    ).length;\n    const [constantVisibleCount, setConstantVisibleCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(visibleCount);\n    const slidesToShow = slideWidth ? constantVisibleCount : propsSlidesToShow;\n    const slidesToScroll = animation === \"fade\" ? slidesToShow : propsSlidesToScroll === \"auto\" ? Math.max(constantVisibleCount, 1) : propsSlidesToScroll;\n    const [currentSlide, setCurrentSlide] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n      () => getDefaultSlideIndex(\n        slideIndex,\n        slideCount,\n        slidesToShow,\n        slidesToScroll,\n        cellAlign,\n        autoplayReverse,\n        scrollMode\n      )\n    );\n    const [pause, setPause] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isDragging, setIsDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [dragDistance, setDragDistance] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [animationDistance, setAnimationDistance] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [isAnimating, setIsAnimating] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const updateSlideIOEntry = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      (id, isFullyVisible) => {\n        if (!!slideIOEntries.get(id) === isFullyVisible)\n          return;\n        setSlideIOEntries((prev) => {\n          const newMap = new Map(prev);\n          newMap.set(id, isFullyVisible);\n          return newMap;\n        });\n      },\n      [slideIOEntries]\n    );\n    const prevDragged = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      if (isDragging)\n        prevDragged.current = true;\n      if (!(isDragging || isAnimating)) {\n        if (!prevDragged.current)\n          setConstantVisibleCount(visibleCount);\n        prevDragged.current = false;\n      }\n    }, [isAnimating, isDragging, visibleCount]);\n    const prevXPosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const preDragOffset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const sliderListRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const defaultCarouselRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const autoplayTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const autoplayLastTriggeredRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const isMounted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const setSliderListRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((node) => {\n      if (node) {\n        node.querySelectorAll(\".slider-list img\").forEach((el) => el.setAttribute(\"draggable\", \"false\"));\n      }\n      sliderListRef.current = node;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      isMounted.current = true;\n      return () => {\n        isMounted.current = false;\n      };\n    }, []);\n    const forwardedRef = useForwardRef(ref);\n    const carouselRef = forwardedRef || defaultCarouselRef;\n    const goToSlide = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      (targetSlideUnbounded) => {\n        if (!sliderListRef.current || !carouselRef.current)\n          return;\n        const targetSlideBounded = getBoundedIndex(\n          targetSlideUnbounded,\n          slideCount\n        );\n        const slideChanged = targetSlideUnbounded !== currentSlide;\n        slideChanged && beforeSlide(currentSlide, targetSlideBounded);\n        const currentOffset = sliderListRef.current.getBoundingClientRect().left - carouselRef.current.getBoundingClientRect().left;\n        const sliderWidth = sliderListRef.current.offsetWidth;\n        let targetOffset = getPercentOffsetForSlide(\n          targetSlideBounded,\n          slideCount,\n          slidesToShow,\n          cellAlign,\n          wrapAround\n        ) / 100 * sliderWidth;\n        if (wrapAround) {\n          const slideSetWidth = sliderWidth / 3;\n          if (targetSlideUnbounded < 0) {\n            targetOffset += slideSetWidth;\n          }\n          if (targetSlideUnbounded >= slideCount) {\n            targetOffset -= slideSetWidth;\n          }\n        }\n        setAnimationDistance(targetOffset - currentOffset);\n        if (slideChanged) {\n          setCurrentSlide(targetSlideBounded);\n          const msToEndOfAnimation = !disableAnimation ? speed || 500 : 40;\n          setTimeout(() => {\n            if (!isMounted.current)\n              return;\n            afterSlide(targetSlideBounded);\n          }, msToEndOfAnimation);\n        }\n      },\n      [\n        afterSlide,\n        beforeSlide,\n        carouselRef,\n        cellAlign,\n        currentSlide,\n        disableAnimation,\n        speed,\n        slideCount,\n        slidesToShow,\n        wrapAround\n      ]\n    );\n    const nextSlide = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n      const nextSlideIndex = getNextMoveIndex(\n        scrollMode,\n        wrapAround,\n        currentSlide,\n        slideCount,\n        slidesToScroll,\n        slidesToShow,\n        cellAlign\n      );\n      if (currentSlide !== nextSlideIndex) {\n        goToSlide(nextSlideIndex);\n      }\n    }, [\n      cellAlign,\n      currentSlide,\n      goToSlide,\n      slidesToScroll,\n      scrollMode,\n      slideCount,\n      slidesToShow,\n      wrapAround\n    ]);\n    const prevSlide = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n      const prevSlideIndex = getPrevMoveIndex(\n        scrollMode,\n        wrapAround,\n        currentSlide,\n        slidesToScroll,\n        slidesToShow,\n        cellAlign\n      );\n      if (currentSlide !== prevSlideIndex) {\n        goToSlide(prevSlideIndex);\n      }\n    }, [\n      cellAlign,\n      currentSlide,\n      goToSlide,\n      slidesToScroll,\n      scrollMode,\n      slidesToShow,\n      wrapAround\n    ]);\n    const prevMovedToSlideIndex = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(slideIndex);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      if (slideIndex !== void 0 && slideIndex !== prevMovedToSlideIndex.current && !autoplayReverse) {\n        goToSlide(slideIndex);\n        prevMovedToSlideIndex.current = slideIndex;\n      }\n    }, [slideIndex, autoplayReverse, goToSlide]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      let pauseStarted = null;\n      if (pause) {\n        pauseStarted = Date.now();\n      }\n      return () => {\n        if (pauseStarted !== null && autoplayLastTriggeredRef.current !== null) {\n          autoplayLastTriggeredRef.current += Date.now() - pauseStarted;\n        }\n      };\n    }, [pause]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      if (autoplay && !pause) {\n        const adjustedTimeoutMs = autoplayLastTriggeredRef.current !== null ? autoplayInterval - (Date.now() - autoplayLastTriggeredRef.current) : autoplayInterval;\n        autoplayTimeout.current = setTimeout(() => {\n          autoplayLastTriggeredRef.current = Date.now();\n          if (autoplayReverse) {\n            prevSlide();\n          } else {\n            nextSlide();\n          }\n        }, adjustedTimeoutMs);\n      }\n      if (autoplay && pause) {\n        clearTimeout(autoplayTimeout.current);\n      }\n      return () => {\n        clearTimeout(autoplayTimeout.current);\n      };\n    }, [\n      pause,\n      autoplay,\n      autoplayInterval,\n      autoplayReverse,\n      prevSlide,\n      nextSlide\n    ]);\n    const onKeyDown = (event) => {\n      let keyCommand = null;\n      Object.keys(keyCodeConfig).forEach(\n        (command) => {\n          var _a;\n          if ((_a = keyCodeConfig[command]) == null ? void 0 : _a.includes(event.keyCode)) {\n            keyCommand = command;\n          }\n        }\n      );\n      if (keyCommand === null)\n        return;\n      event.preventDefault();\n      event.stopPropagation();\n      switch (keyCommand) {\n        case \"nextSlide\":\n          onUserNavigation(event);\n          nextSlide();\n          break;\n        case \"previousSlide\":\n          onUserNavigation(event);\n          prevSlide();\n          break;\n        case \"firstSlide\":\n        case \"lastSlide\": {\n          onUserNavigation(event);\n          const dotIndices = getDotIndexes(\n            slideCount,\n            slidesToScroll,\n            scrollMode,\n            slidesToShow,\n            wrapAround,\n            cellAlign\n          );\n          if (keyCommand === \"firstSlide\") {\n            goToSlide(dotIndices[0]);\n          } else {\n            goToSlide(dotIndices[dotIndices.length - 1]);\n          }\n          break;\n        }\n        case \"pause\":\n          setPause((p) => !p);\n          break;\n      }\n    };\n    const dragPositions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const handleDragEnd = (e) => {\n      if (!isDragging || !carouselRef.current)\n        return;\n      setIsDragging(false);\n      let distanceFromInertia = 0;\n      if (dragPositions.current.length > 1) {\n        const startMove = dragPositions.current[0];\n        const endMove = dragPositions.current[dragPositions.current.length - 1];\n        const timeOffset = endMove.time - startMove.time;\n        const goodInertiaFeelConstant = 9;\n        const goodFrictionFeelConstant = 0.92;\n        const initialVelocity = goodInertiaFeelConstant * Math.abs((endMove.pos - startMove.pos) / timeOffset);\n        let velocity = initialVelocity;\n        while (Math.abs(velocity) > 1) {\n          distanceFromInertia += velocity;\n          velocity *= goodFrictionFeelConstant;\n        }\n      }\n      dragPositions.current = [];\n      const adjustedDragDistance = Math.abs(dragDistance) + Math.abs(distanceFromInertia);\n      onDragEnd(e);\n      prevXPosition.current = null;\n      setDragDistance(0);\n      const oneScrollWidth = carouselRef.current.offsetWidth * Math.min(1, slidesToScroll / slidesToShow);\n      const dragThreshold = oneScrollWidth * propsDragThreshold;\n      if (adjustedDragDistance < dragThreshold) {\n        goToSlide(currentSlide);\n        return;\n      }\n      const canMaintainVisualContinuity = slidesToShow >= 2 * slidesToScroll;\n      const timesToMove = canMaintainVisualContinuity ? 1 + Math.floor((adjustedDragDistance - dragThreshold) / oneScrollWidth) : 1;\n      let nextSlideIndex = currentSlide;\n      for (let index = 0; index < timesToMove; index += 1) {\n        if (dragDistance > 0) {\n          nextSlideIndex = getNextMoveIndex(\n            scrollMode,\n            wrapAround,\n            nextSlideIndex,\n            slideCount,\n            slidesToScroll,\n            slidesToShow,\n            cellAlign\n          );\n        } else {\n          nextSlideIndex = getPrevMoveIndex(\n            scrollMode,\n            wrapAround,\n            nextSlideIndex,\n            slidesToScroll,\n            slidesToShow,\n            cellAlign\n          );\n        }\n      }\n      if (nextSlideIndex !== currentSlide) {\n        onUserNavigation(e);\n      }\n      goToSlide(nextSlideIndex);\n    };\n    const onTouchStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      (e) => {\n        if (!mobileDraggingEnabled || !sliderListRef.current || !carouselRef.current) {\n          return;\n        }\n        setIsDragging(true);\n        preDragOffset.current = sliderListRef.current.getBoundingClientRect().left - carouselRef.current.getBoundingClientRect().left;\n        onDragStart(e);\n      },\n      [carouselRef, onDragStart, mobileDraggingEnabled]\n    );\n    const handlePointerMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      (xPosition) => {\n        if (!isDragging)\n          return;\n        const isFirstMove = prevXPosition.current === null;\n        const delta = prevXPosition.current !== null ? xPosition - prevXPosition.current : 0;\n        const nextDragDistance = dragDistance + delta;\n        const now = Date.now();\n        while (dragPositions.current.length > 0) {\n          if (now - dragPositions.current[0].time <= 100) {\n            break;\n          }\n          dragPositions.current.shift();\n        }\n        dragPositions.current.push({ pos: nextDragDistance, time: now });\n        if (!isFirstMove) {\n          setDragDistance(nextDragDistance);\n        }\n        prevXPosition.current = xPosition;\n      },\n      [isDragging, dragDistance]\n    );\n    const onTouchMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      (e) => {\n        if (!isDragging || !carouselRef.current)\n          return;\n        onDragStart(e);\n        const moveValue = carouselRef.current.offsetWidth - e.touches[0].pageX;\n        handlePointerMove(moveValue);\n      },\n      [isDragging, carouselRef, handlePointerMove, onDragStart]\n    );\n    const onMouseDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      (e) => {\n        if (!desktopDraggingEnabled || !sliderListRef.current || !carouselRef.current)\n          return;\n        setIsDragging(true);\n        preDragOffset.current = sliderListRef.current.getBoundingClientRect().left - carouselRef.current.getBoundingClientRect().left;\n        onDragStart(e);\n      },\n      [carouselRef, desktopDraggingEnabled, onDragStart]\n    );\n    const onMouseMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      (e) => {\n        if (!isDragging || !carouselRef.current)\n          return;\n        onDrag(e);\n        const offsetX = e.clientX - carouselRef.current.getBoundingClientRect().left;\n        const moveValue = carouselRef.current.offsetWidth - offsetX;\n        handlePointerMove(moveValue);\n      },\n      [carouselRef, isDragging, handlePointerMove, onDrag]\n    );\n    const onMouseUp = (e) => {\n      e.preventDefault();\n      handleDragEnd(e);\n    };\n    const onMouseEnter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n      if (pauseOnHover) {\n        setPause(true);\n      }\n    }, [pauseOnHover]);\n    const onMouseLeave = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n      if (pauseOnHover) {\n        setPause(false);\n      }\n    }, [pauseOnHover]);\n    const {\n      frameHeight,\n      handleVisibleSlideHeightChange,\n      initializedAdaptiveHeight\n    } = useFrameHeight(adaptiveHeight, slidesToShow, slideCount);\n    const renderSlides = (typeOfSlide) => {\n      const slides = filteredSlides.map((child, index) => {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          slide_default,\n          {\n            id: `${typeOfSlide}-${index}`,\n            carouselId,\n            count: slideCount,\n            index,\n            isCurrentSlide: currentSlide === index,\n            typeOfSlide,\n            wrapAround,\n            cellSpacing,\n            animation,\n            speed,\n            zoomScale,\n            onVisibleSlideHeightChange: handleVisibleSlideHeightChange,\n            slideWidth,\n            updateIOEntry: updateSlideIOEntry,\n            adaptiveHeight,\n            initializedAdaptiveHeight,\n            carouselRef,\n            tabbed,\n            children: child\n          },\n          `${typeOfSlide}-${index}`\n        );\n      });\n      return slides;\n    };\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\n      \"div\",\n      {\n        className: \"slider-container\",\n        style: {\n          position: \"relative\"\n        },\n        onMouseEnter,\n        onMouseLeave,\n        \"aria-label\": frameAriaLabel,\n        role: landmark ? \"region\" : \"group\",\n        \"aria-roledescription\": \"carousel\",\n        id: carouselId,\n        \"data-testid\": carouselId,\n        children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n            announce_slide_default,\n            {\n              ariaLive: autoplay && !pause ? \"off\" : \"polite\",\n              message: renderAnnounceSlideMessage({\n                currentSlide,\n                count: slideCount\n              })\n            }\n          ),\n          controls_default(\n            __spreadProps(__spreadValues({}, props), { carouselId }),\n            slideCount,\n            currentSlide,\n            goToSlide,\n            nextSlide,\n            prevSlide,\n            slidesToScroll\n          ),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n            \"div\",\n            {\n              className: [\"slider-frame\", className || \"\"].join(\" \").trim(),\n              style: __spreadValues({\n                overflow: \"hidden\",\n                width: \"100%\",\n                position: \"relative\",\n                outline: \"none\",\n                touchAction: \"pan-y\",\n                height: frameHeight,\n                transition: adaptiveHeightAnimation ? \"height 300ms ease-in-out\" : void 0,\n                willChange: \"height\",\n                userSelect: \"none\"\n              }, style),\n              tabIndex: enableKeyboardControls ? 0 : -1,\n              onKeyDown: enableKeyboardControls ? onKeyDown : void 0,\n              ref: carouselRef,\n              onMouseUp,\n              onMouseDown,\n              onMouseMove,\n              onMouseLeave: onMouseUp,\n              onTouchStart,\n              onTouchEnd: handleDragEnd,\n              onTouchMove,\n              id: `${carouselId}-slider-frame`,\n              \"data-testid\": `${carouselId}-slider-frame`,\n              children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\n                SliderList,\n                {\n                  animationDistance,\n                  cellAlign,\n                  currentSlide,\n                  disableEdgeSwiping: props.disableEdgeSwiping,\n                  draggedOffset: preDragOffset.current - dragDistance,\n                  disableAnimation,\n                  easing: props.easing,\n                  edgeEasing: props.edgeEasing,\n                  isDragging,\n                  ref: setSliderListRef,\n                  scrollMode,\n                  animation,\n                  slideCount,\n                  slidesToScroll,\n                  slidesToShow,\n                  speed,\n                  slideWidth,\n                  wrapAround,\n                  setIsAnimating,\n                  children: [\n                    wrapAround ? renderSlides(\"prev-cloned\") : null,\n                    renderSlides(),\n                    wrapAround ? renderSlides(\"next-cloned\") : null\n                  ]\n                }\n              )\n            }\n          )\n        ]\n      }\n    );\n  }\n);\nCarousel.defaultProps = default_carousel_props_default;\nCarousel.displayName = \"Carousel\";\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbnVrYS1jYXJvdXNlbC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3NJOztBQUV0STtBQUllOztBQUVmO0FBQ29EO0FBQ3BEO0FBQ0EsNEJBQTRCLCtDQUFRO0FBQ3BDLHNCQUFzQiw2Q0FBTTtBQUM1QixFQUFFLGdEQUFTO0FBQ1g7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUN3QztBQUN4Qyw4Q0FBOEMsNkNBQTZDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRCwrQkFBK0Isd0JBQXdCO0FBQ3ZELCtDQUErQyx5REFBeUQ7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsbUJBQW1CLDZDQUFPO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQiw2Q0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDLGdDQUFnQyxXQUFXO0FBQzNDLHdDQUF3Qyx1REFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iYWJ5eWVwLy4vbm9kZV9tb2R1bGVzL251a2EtY2Fyb3VzZWwvZGlzdC9pbmRleC5tanM/ZTkyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX3BvdyA9IE1hdGgucG93O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuXG4vLyBzcmMvY2Fyb3VzZWwudHN4XG5pbXBvcnQgUmVhY3Q1LCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q2LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTUsIHVzZVJlZiBhcyB1c2VSZWY2LCB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazQsIHVzZUlkIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9zbGlkZS50c3hcbmltcG9ydCB7XG4gIHVzZVJlZiBhcyB1c2VSZWYyLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MlxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2hvb2tzL3VzZS1zbGlkZS1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXIudHNcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZVNsaWRlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSAoZWxlbWVudFJlZiwgcm9vdFJlZiwgY2FsbGJhY2spID0+IHtcbiAgY29uc3QgW2VudHJ5LCBzZXRFbnRyeV0gPSB1c2VTdGF0ZSgpO1xuICBjb25zdCBjYWxsYmFja1JlZiA9IHVzZVJlZihjYWxsYmFjayk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2FsbGJhY2tSZWYuY3VycmVudCA9IGNhbGxiYWNrO1xuICB9LCBbY2FsbGJhY2tdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBub2RlID0gZWxlbWVudFJlZiA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudFJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHJvb3QgPSByb290UmVmID09IG51bGwgPyB2b2lkIDAgOiByb290UmVmLmN1cnJlbnQ7XG4gICAgaWYgKCF3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgfHwgIW5vZGUgfHwgIXJvb3QpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAoZW50cmllcykgPT4ge1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5MikgPT4ge1xuICAgICAgICAgIHNldEVudHJ5KGVudHJ5Mik7XG4gICAgICAgICAgY2FsbGJhY2tSZWYuY3VycmVudChlbnRyeTIpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRocmVzaG9sZDogWzAuMDUsIDAuOTVdLFxuICAgICAgICByb290XG4gICAgICB9XG4gICAgKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUpO1xuICAgIHJldHVybiAoKSA9PiBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH0sIFtlbGVtZW50UmVmLCByb290UmVmXSk7XG4gIHJldHVybiBlbnRyeTtcbn07XG5cbi8vIHNyYy9zbGlkZS50c3hcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIGdldFNsaWRlV2lkdGggPSAoY291bnQsIHdyYXBBcm91bmQpID0+IGAke3dyYXBBcm91bmQgPyAxMDAgLyAoMyAqIGNvdW50KSA6IDEwMCAvIGNvdW50fSVgO1xudmFyIGdldFNsaWRlU3R5bGVzID0gKGNvdW50LCBpc0N1cnJlbnRTbGlkZSwgaXNWaXNpYmxlU2xpZGUsIHdyYXBBcm91bmQsIGNlbGxTcGFjaW5nLCBhbmltYXRpb24sIHNwZWVkLCB6b29tU2NhbGUsIGFkYXB0aXZlSGVpZ2h0LCBpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0LCBzbGlkZVdpZHRoKSA9PiB7XG4gIGNvbnN0IHdpZHRoID0gc2xpZGVXaWR0aCAhPSBudWxsID8gc2xpZGVXaWR0aCA6IGdldFNsaWRlV2lkdGgoY291bnQsIHdyYXBBcm91bmQpO1xuICBjb25zdCB2aXNpYmxlU2xpZGVPcGFjaXR5ID0gaXNWaXNpYmxlU2xpZGUgPyAxIDogMDtcbiAgY29uc3QgYW5pbWF0aW9uU3BlZWQgPSBhbmltYXRpb24gPT09IFwiZmFkZVwiID8gMjAwIDogNTAwO1xuICBsZXQgaGVpZ2h0ID0gXCJhdXRvXCI7XG4gIGlmIChhZGFwdGl2ZUhlaWdodCkge1xuICAgIGlmIChpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBcIjEwMCVcIjtcbiAgICB9IGVsc2UgaWYgKGlzVmlzaWJsZVNsaWRlKSB7XG4gICAgICBoZWlnaHQgPSBcImF1dG9cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gXCIwXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHBhZGRpbmc6IGAwICR7Y2VsbFNwYWNpbmcgPyBjZWxsU3BhY2luZyAvIDIgOiAwfXB4YCxcbiAgICB0cmFuc2l0aW9uOiBhbmltYXRpb24gPyBgJHtzcGVlZCB8fCBhbmltYXRpb25TcGVlZH1tcyBlYXNlIDBzYCA6IHZvaWQgMCxcbiAgICB0cmFuc2Zvcm06IGFuaW1hdGlvbiA9PT0gXCJ6b29tXCIgPyBgc2NhbGUoJHtpc0N1cnJlbnRTbGlkZSAmJiBpc1Zpc2libGVTbGlkZSA/IDEgOiB6b29tU2NhbGUgfHwgMC44NX0pYCA6IHZvaWQgMCxcbiAgICBvcGFjaXR5OiBhbmltYXRpb24gPT09IFwiZmFkZVwiID8gdmlzaWJsZVNsaWRlT3BhY2l0eSA6IDFcbiAgfTtcbn07XG52YXIgZ2VuZXJhdGVJbmRleCA9IChpbmRleCwgY291bnQsIHR5cGVPZlNsaWRlKSA9PiB7XG4gIGlmICh0eXBlT2ZTbGlkZSA9PT0gXCJwcmV2LWNsb25lZFwiKSB7XG4gICAgcmV0dXJuIGluZGV4IC0gY291bnQ7XG4gIH1cbiAgaWYgKHR5cGVPZlNsaWRlID09PSBcIm5leHQtY2xvbmVkXCIpIHtcbiAgICByZXR1cm4gaW5kZXggKyBjb3VudDtcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59O1xudmFyIFNsaWRlID0gKHtcbiAgY291bnQsXG4gIGNoaWxkcmVuLFxuICBpbmRleCxcbiAgaXNDdXJyZW50U2xpZGUsXG4gIHR5cGVPZlNsaWRlLFxuICB3cmFwQXJvdW5kLFxuICBjZWxsU3BhY2luZyxcbiAgc2xpZGVXaWR0aCxcbiAgYW5pbWF0aW9uLFxuICBzcGVlZCxcbiAgem9vbVNjYWxlLFxuICBvblZpc2libGVTbGlkZUhlaWdodENoYW5nZSxcbiAgYWRhcHRpdmVIZWlnaHQsXG4gIGluaXRpYWxpemVkQWRhcHRpdmVIZWlnaHQsXG4gIHVwZGF0ZUlPRW50cnksXG4gIGlkLFxuICBjYXJvdXNlbFJlZixcbiAgY2Fyb3VzZWxJZCxcbiAgdGFiYmVkXG59KSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgY3VzdG9tSW5kZXggPSB3cmFwQXJvdW5kID8gZ2VuZXJhdGVJbmRleChpbmRleCwgY291bnQsIHR5cGVPZlNsaWRlKSA6IGluZGV4O1xuICBjb25zdCBzbGlkZVJlZiA9IHVzZVJlZjIobnVsbCk7XG4gIGNvbnN0IGVudHJ5ID0gdXNlU2xpZGVJbnRlcnNlY3Rpb25PYnNlcnZlcihzbGlkZVJlZiwgY2Fyb3VzZWxSZWYsIChlbnRyeTIpID0+IHtcbiAgICB1cGRhdGVJT0VudHJ5KGlkLCAoZW50cnkyID09IG51bGwgPyB2b2lkIDAgOiBlbnRyeTIuaW50ZXJzZWN0aW9uUmF0aW8pID49IDAuOTUpO1xuICB9KTtcbiAgY29uc3QgaXNWaXNpYmxlID0gISEoZW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IGVudHJ5LmlzSW50ZXJzZWN0aW5nKTtcbiAgY29uc3QgaXNGdWxseVZpc2libGUgPSAoKF9hID0gZW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IGVudHJ5LmludGVyc2VjdGlvblJhdGlvKSAhPSBudWxsID8gX2EgOiAxKSA+PSAwLjk1O1xuICBjb25zdCBwcmV2SXNWaXNpYmxlUmVmID0gdXNlUmVmMihmYWxzZSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgY29uc3Qgbm9kZSA9IHNsaWRlUmVmLmN1cnJlbnQ7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIGNvbnN0IHNsaWRlSGVpZ2h0ID0gKF9hMiA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaGVpZ2h0O1xuICAgICAgY29uc3QgcHJldklzVmlzaWJsZSA9IHByZXZJc1Zpc2libGVSZWYuY3VycmVudDtcbiAgICAgIGlmIChpc1Zpc2libGUgJiYgIXByZXZJc1Zpc2libGUpIHtcbiAgICAgICAgb25WaXNpYmxlU2xpZGVIZWlnaHRDaGFuZ2UoY3VzdG9tSW5kZXgsIHNsaWRlSGVpZ2h0KTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzVmlzaWJsZSAmJiBwcmV2SXNWaXNpYmxlKSB7XG4gICAgICAgIG9uVmlzaWJsZVNsaWRlSGVpZ2h0Q2hhbmdlKGN1c3RvbUluZGV4LCBudWxsKTtcbiAgICAgIH1cbiAgICAgIHByZXZJc1Zpc2libGVSZWYuY3VycmVudCA9IGlzVmlzaWJsZTtcbiAgICB9XG4gIH0sIFtjdXN0b21JbmRleCwgaXNWaXNpYmxlLCBvblZpc2libGVTbGlkZUhlaWdodENoYW5nZV0pO1xuICBjb25zdCBjdXJyZW50U2xpZGVDbGFzcyA9IGlzQ3VycmVudFNsaWRlICYmIGlzRnVsbHlWaXNpYmxlID8gXCIgc2xpZGUtY3VycmVudFwiIDogXCJcIjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgXCJkaXZcIixcbiAgICBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHJlZjogc2xpZGVSZWZcbiAgICB9LCB7IGluZXJ0OiBpc0Z1bGx5VmlzaWJsZSA/IHZvaWQgMCA6IFwidHJ1ZVwiIH0pLCB7XG4gICAgICBjbGFzc05hbWU6IGBzbGlkZSR7Y3VycmVudFNsaWRlQ2xhc3N9JHt0eXBlT2ZTbGlkZSA/IGAgJHt0eXBlT2ZTbGlkZX1gIDogXCJcIn0ke2lzRnVsbHlWaXNpYmxlID8gXCIgc2xpZGUtdmlzaWJsZVwiIDogXCJcIn1gLFxuICAgICAgc3R5bGU6IGdldFNsaWRlU3R5bGVzKFxuICAgICAgICBjb3VudCxcbiAgICAgICAgaXNDdXJyZW50U2xpZGUsXG4gICAgICAgIGlzRnVsbHlWaXNpYmxlLFxuICAgICAgICB3cmFwQXJvdW5kLFxuICAgICAgICBjZWxsU3BhY2luZyxcbiAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICBzcGVlZCxcbiAgICAgICAgem9vbVNjYWxlLFxuICAgICAgICBhZGFwdGl2ZUhlaWdodCxcbiAgICAgICAgaW5pdGlhbGl6ZWRBZGFwdGl2ZUhlaWdodCxcbiAgICAgICAgc2xpZGVXaWR0aFxuICAgICAgKSxcbiAgICAgIGlkOiB0eXBlT2ZTbGlkZSA/IHZvaWQgMCA6IGAke2Nhcm91c2VsSWR9LXNsaWRlLSR7aW5kZXggKyAxfWAsXG4gICAgICByb2xlOiB0YWJiZWQgPyBcInRhYnBhbmVsXCIgOiBcImdyb3VwXCIsXG4gICAgICBcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCI6IHRhYmJlZCA/IHZvaWQgMCA6IFwic2xpZGVcIixcbiAgICAgIGNoaWxkcmVuXG4gICAgfSlcbiAgKTtcbn07XG52YXIgc2xpZGVfZGVmYXVsdCA9IFNsaWRlO1xuXG4vLyBzcmMvYW5ub3VuY2Utc2xpZGUudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIHN0eWxlcyA9IHtcbiAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgd2lkdGg6IFwiMXB4XCIsXG4gIGhlaWdodDogXCIxcHhcIixcbiAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gIHBhZGRpbmc6IDAsXG4gIG1hcmdpbjogXCItMXB4XCIsXG4gIGNsaXA6IFwicmVjdCgwLCAwLCAwLCAwKVwiLFxuICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiLFxuICBib3JkZXI6IDBcbn07XG52YXIgQW5ub3VuY2VTbGlkZSA9ICh7XG4gIG1lc3NhZ2UsXG4gIGFyaWFMaXZlID0gXCJwb2xpdGVcIlxufSkgPT4gLyogQF9fUFVSRV9fICovIGpzeDIoXCJkaXZcIiwgeyBcImFyaWEtbGl2ZVwiOiBhcmlhTGl2ZSwgXCJhcmlhLWF0b21pY1wiOiBcInRydWVcIiwgc3R5bGU6IHN0eWxlcywgdGFiSW5kZXg6IC0xLCBjaGlsZHJlbjogbWVzc2FnZSB9KTtcbnZhciBkZWZhdWx0UmVuZGVyQW5ub3VuY2VTbGlkZU1lc3NhZ2UgPSAoe1xuICBjdXJyZW50U2xpZGUsXG4gIGNvdW50XG59KSA9PiBgU2xpZGUgJHtjdXJyZW50U2xpZGUgKyAxfSBvZiAke2NvdW50fWA7XG52YXIgYW5ub3VuY2Vfc2xpZGVfZGVmYXVsdCA9IEFubm91bmNlU2xpZGU7XG5cbi8vIHNyYy9zbGlkZXItbGlzdC50c3hcbmltcG9ydCBSZWFjdDMsIHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDQgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2RlZmF1bHQtY29udHJvbHMudHN4XG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdHlwZXMudHNcbnZhciBBbGlnbm1lbnQgPSAvKiBAX19QVVJFX18gKi8gKChBbGlnbm1lbnQyKSA9PiB7XG4gIEFsaWdubWVudDJbXCJDZW50ZXJcIl0gPSBcImNlbnRlclwiO1xuICBBbGlnbm1lbnQyW1wiUmlnaHRcIl0gPSBcInJpZ2h0XCI7XG4gIEFsaWdubWVudDJbXCJMZWZ0XCJdID0gXCJsZWZ0XCI7XG4gIHJldHVybiBBbGlnbm1lbnQyO1xufSkoQWxpZ25tZW50IHx8IHt9KTtcbnZhciBEaXJlY3Rpb25zID0gLyogQF9fUFVSRV9fICovICgoRGlyZWN0aW9uczIpID0+IHtcbiAgRGlyZWN0aW9uczJbXCJOZXh0XCJdID0gXCJuZXh0XCI7XG4gIERpcmVjdGlvbnMyW1wiUHJldlwiXSA9IFwicHJldlwiO1xuICBEaXJlY3Rpb25zMltcIlVwXCJdID0gXCJ1cFwiO1xuICBEaXJlY3Rpb25zMltcIkRvd25cIl0gPSBcImRvd25cIjtcbiAgcmV0dXJuIERpcmVjdGlvbnMyO1xufSkoRGlyZWN0aW9ucyB8fCB7fSk7XG52YXIgUG9zaXRpb25zID0gLyogQF9fUFVSRV9fICovICgoUG9zaXRpb25zMikgPT4ge1xuICBQb3NpdGlvbnMyW1wiVG9wTGVmdFwiXSA9IFwiVG9wTGVmdFwiO1xuICBQb3NpdGlvbnMyW1wiVG9wQ2VudGVyXCJdID0gXCJUb3BDZW50ZXJcIjtcbiAgUG9zaXRpb25zMltcIlRvcFJpZ2h0XCJdID0gXCJUb3BSaWdodFwiO1xuICBQb3NpdGlvbnMyW1wiQ2VudGVyTGVmdFwiXSA9IFwiQ2VudGVyTGVmdFwiO1xuICBQb3NpdGlvbnMyW1wiQ2VudGVyQ2VudGVyXCJdID0gXCJDZW50ZXJDZW50ZXJcIjtcbiAgUG9zaXRpb25zMltcIkNlbnRlclJpZ2h0XCJdID0gXCJDZW50ZXJSaWdodFwiO1xuICBQb3NpdGlvbnMyW1wiQm90dG9tTGVmdFwiXSA9IFwiQm90dG9tTGVmdFwiO1xuICBQb3NpdGlvbnMyW1wiQm90dG9tQ2VudGVyXCJdID0gXCJCb3R0b21DZW50ZXJcIjtcbiAgUG9zaXRpb25zMltcIkJvdHRvbVJpZ2h0XCJdID0gXCJCb3R0b21SaWdodFwiO1xuICByZXR1cm4gUG9zaXRpb25zMjtcbn0pKFBvc2l0aW9ucyB8fCB7fSk7XG52YXIgU2Nyb2xsTW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFNjcm9sbE1vZGUyKSA9PiB7XG4gIFNjcm9sbE1vZGUyW1wicGFnZVwiXSA9IFwicGFnZVwiO1xuICBTY3JvbGxNb2RlMltcInJlbWFpbmRlclwiXSA9IFwicmVtYWluZGVyXCI7XG4gIHJldHVybiBTY3JvbGxNb2RlMjtcbn0pKFNjcm9sbE1vZGUgfHwge30pO1xuXG4vLyBzcmMvdXRpbHMudHNcbnZhciBnZXROZXh0TW92ZUluZGV4ID0gKHNjcm9sbE1vZGUsIHdyYXBBcm91bmQsIGN1cnJlbnRTbGlkZSwgc2xpZGVDb3VudCwgc2xpZGVzVG9TY3JvbGwsIHNsaWRlc1RvU2hvdywgY2VsbEFsaWduKSA9PiB7XG4gIGlmICh3cmFwQXJvdW5kKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTbGlkZSArIHNsaWRlc1RvU2Nyb2xsO1xuICB9XG4gIGlmIChjdXJyZW50U2xpZGUgPj0gc2xpZGVDb3VudCAtIDEgfHwgY2VsbEFsaWduID09PSBcImxlZnRcIiAmJiBjdXJyZW50U2xpZGUgPj0gc2xpZGVDb3VudCAtIHNsaWRlc1RvU2hvdykge1xuICAgIHJldHVybiBjdXJyZW50U2xpZGU7XG4gIH1cbiAgaWYgKHNjcm9sbE1vZGUgPT09IFwicmVtYWluZGVyXCIgLyogcmVtYWluZGVyICovICYmIGNlbGxBbGlnbiA9PT0gXCJsZWZ0XCIpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oY3VycmVudFNsaWRlICsgc2xpZGVzVG9TY3JvbGwsIHNsaWRlQ291bnQgLSBzbGlkZXNUb1Nob3cpO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihjdXJyZW50U2xpZGUgKyBzbGlkZXNUb1Njcm9sbCwgc2xpZGVDb3VudCAtIDEpO1xufTtcbnZhciBnZXRQcmV2TW92ZUluZGV4ID0gKHNjcm9sbE1vZGUsIHdyYXBBcm91bmQsIGN1cnJlbnRTbGlkZSwgc2xpZGVzVG9TY3JvbGwsIHNsaWRlc1RvU2hvdywgY2VsbEFsaWduKSA9PiB7XG4gIGlmICh3cmFwQXJvdW5kKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTbGlkZSAtIHNsaWRlc1RvU2Nyb2xsO1xuICB9XG4gIGlmIChjdXJyZW50U2xpZGUgPD0gMCB8fCBjZWxsQWxpZ24gPT09IFwicmlnaHRcIiAmJiBjdXJyZW50U2xpZGUgPD0gc2xpZGVzVG9TaG93IC0gMSkge1xuICAgIHJldHVybiBjdXJyZW50U2xpZGU7XG4gIH1cbiAgaWYgKHNjcm9sbE1vZGUgPT09IFwicmVtYWluZGVyXCIgLyogcmVtYWluZGVyICovICYmIGNlbGxBbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KGN1cnJlbnRTbGlkZSAtIHNsaWRlc1RvU2Nyb2xsLCBzbGlkZXNUb1Nob3cgLSAxKTtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoY3VycmVudFNsaWRlIC0gc2xpZGVzVG9TY3JvbGwsIDApO1xufTtcbnZhciBnZXREZWZhdWx0U2xpZGVJbmRleCA9IChzbGlkZUluZGV4LCBzbGlkZUNvdW50LCBzbGlkZXNUb1Nob3csIHNsaWRlc1RvU2Nyb2xsLCBjZWxsQWxpZ24sIGF1dG9wbGF5UmV2ZXJzZSwgc2Nyb2xsTW9kZSkgPT4ge1xuICBpZiAoc2xpZGVJbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHNsaWRlSW5kZXg7XG4gIH1cbiAgY29uc3QgZG90SW5kZXhlcyA9IGdldERvdEluZGV4ZXMoXG4gICAgc2xpZGVDb3VudCxcbiAgICBzbGlkZXNUb1Njcm9sbCxcbiAgICBzY3JvbGxNb2RlLFxuICAgIHNsaWRlc1RvU2hvdyxcbiAgICBmYWxzZSxcbiAgICBjZWxsQWxpZ25cbiAgKTtcbiAgcmV0dXJuIGF1dG9wbGF5UmV2ZXJzZSA/IGRvdEluZGV4ZXNbZG90SW5kZXhlcy5sZW5ndGggLSAxXSA6IGRvdEluZGV4ZXNbMF07XG59O1xudmFyIGdldEJvdW5kZWRJbmRleCA9IChyYXdJbmRleCwgc2xpZGVDb3VudCkgPT4ge1xuICByZXR1cm4gKHJhd0luZGV4ICUgc2xpZGVDb3VudCArIHNsaWRlQ291bnQpICUgc2xpZGVDb3VudDtcbn07XG5cbi8vIHNyYy9kZWZhdWx0LWNvbnRyb2xzLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBkZWZhdWx0QnV0dG9uU3R5bGVzID0gKGRpc2FibGVkKSA9PiAoe1xuICBib3JkZXI6IDAsXG4gIGJhY2tncm91bmQ6IFwicmdiYSgwLDAsMCwwLjQpXCIsXG4gIGNvbG9yOiBcIndoaXRlXCIsXG4gIHBhZGRpbmc6IDEwLFxuICB0ZXh0VHJhbnNmb3JtOiBcInVwcGVyY2FzZVwiLFxuICBvcGFjaXR5OiBkaXNhYmxlZCA/IDAuMyA6IDEsXG4gIGN1cnNvcjogZGlzYWJsZWQgPyBcIm5vdC1hbGxvd2VkXCIgOiBcInBvaW50ZXJcIlxufSk7XG52YXIgcHJldkJ1dHRvbkRpc2FibGVkID0gKHtcbiAgY2VsbEFsaWduLFxuICBjdXJyZW50U2xpZGUsXG4gIHNsaWRlc1RvU2hvdyxcbiAgd3JhcEFyb3VuZFxufSkgPT4ge1xuICBpZiAod3JhcEFyb3VuZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoY3VycmVudFNsaWRlID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGNlbGxBbGlnbiA9PT0gXCJyaWdodFwiICYmIGN1cnJlbnRTbGlkZSA8PSBzbGlkZXNUb1Nob3cgLSAxKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBQcmV2aW91c0J1dHRvbiA9ICh7XG4gIHByZXZpb3VzU2xpZGUsXG4gIGRlZmF1bHRDb250cm9sc0NvbmZpZzoge1xuICAgIHByZXZCdXR0b25DbGFzc05hbWUsXG4gICAgcHJldkJ1dHRvblN0eWxlID0ge30sXG4gICAgcHJldkJ1dHRvblRleHQsXG4gICAgcHJldkJ1dHRvbk9uQ2xpY2tcbiAgfSxcbiAgb25Vc2VyTmF2aWdhdGlvbixcbiAgY2Fyb3VzZWxJZCxcbiAgcHJldmlvdXNEaXNhYmxlZDogZGlzYWJsZWRcbn0pID0+IHtcbiAgY29uc3QgaGFuZGxlQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICBwcmV2QnV0dG9uT25DbGljayA9PSBudWxsID8gdm9pZCAwIDogcHJldkJ1dHRvbk9uQ2xpY2soZXZlbnQpO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIG9uVXNlck5hdmlnYXRpb24oZXZlbnQpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgcHJldmlvdXNTbGlkZSgpO1xuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMoXG4gICAgXCJidXR0b25cIixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IHByZXZCdXR0b25DbGFzc05hbWUsXG4gICAgICBzdHlsZTogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGRlZmF1bHRCdXR0b25TdHlsZXMoZGlzYWJsZWQpKSwgcHJldkJ1dHRvblN0eWxlKSxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgICBcImFyaWEtbGFiZWxcIjogXCJwcmV2aW91c1wiLFxuICAgICAgXCJhcmlhLWNvbnRyb2xzXCI6IGAke2Nhcm91c2VsSWR9LXNsaWRlci1mcmFtZWAsXG4gICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgY2hpbGRyZW46IHByZXZCdXR0b25UZXh0IHx8IFwiUHJldlwiXG4gICAgfVxuICApO1xufTtcbnZhciBuZXh0QnV0dG9uRGlzYWJsZWQgPSAoe1xuICBjZWxsQWxpZ24sXG4gIGN1cnJlbnRTbGlkZSxcbiAgc2xpZGVDb3VudCxcbiAgc2xpZGVzVG9TaG93LFxuICB3cmFwQXJvdW5kXG59KSA9PiB7XG4gIGlmICh3cmFwQXJvdW5kKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjdXJyZW50U2xpZGUgPj0gc2xpZGVDb3VudCAtIDEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoY2VsbEFsaWduID09PSBcImxlZnRcIiAmJiBjdXJyZW50U2xpZGUgPj0gc2xpZGVDb3VudCAtIHNsaWRlc1RvU2hvdykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgTmV4dEJ1dHRvbiA9ICh7XG4gIG5leHRTbGlkZSxcbiAgZGVmYXVsdENvbnRyb2xzQ29uZmlnOiB7XG4gICAgbmV4dEJ1dHRvbkNsYXNzTmFtZSxcbiAgICBuZXh0QnV0dG9uU3R5bGUgPSB7fSxcbiAgICBuZXh0QnV0dG9uVGV4dCxcbiAgICBuZXh0QnV0dG9uT25DbGlja1xuICB9LFxuICBjYXJvdXNlbElkLFxuICBuZXh0RGlzYWJsZWQ6IGRpc2FibGVkLFxuICBvblVzZXJOYXZpZ2F0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgbmV4dEJ1dHRvbk9uQ2xpY2sgPT0gbnVsbCA/IHZvaWQgMCA6IG5leHRCdXR0b25PbkNsaWNrKGV2ZW50KTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICBvblVzZXJOYXZpZ2F0aW9uKGV2ZW50KTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIG5leHRTbGlkZSgpO1xuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMoXG4gICAgXCJidXR0b25cIixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IG5leHRCdXR0b25DbGFzc05hbWUsXG4gICAgICBzdHlsZTogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGRlZmF1bHRCdXR0b25TdHlsZXMoZGlzYWJsZWQpKSwgbmV4dEJ1dHRvblN0eWxlKSxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgICBcImFyaWEtbGFiZWxcIjogXCJuZXh0XCIsXG4gICAgICBcImFyaWEtY29udHJvbHNcIjogYCR7Y2Fyb3VzZWxJZH0tc2xpZGVyLWZyYW1lYCxcbiAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICBjaGlsZHJlbjogbmV4dEJ1dHRvblRleHQgfHwgXCJOZXh0XCJcbiAgICB9XG4gICk7XG59O1xudmFyIGdldERvdEluZGV4ZXMgPSAoc2xpZGVDb3VudCwgc2xpZGVzVG9TY3JvbGwsIHNjcm9sbE1vZGUsIHNsaWRlc1RvU2hvdywgd3JhcEFyb3VuZCwgY2VsbEFsaWduKSA9PiB7XG4gIGNvbnN0IGRvdEluZGV4ZXMgPSBbXTtcbiAgY29uc3Qgc2Nyb2xsU2xpZGVzID0gc2xpZGVzVG9TY3JvbGwgPD0gMCA/IDEgOiBzbGlkZXNUb1Njcm9sbDtcbiAgaWYgKHdyYXBBcm91bmQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlQ291bnQ7IGkgKz0gc2Nyb2xsU2xpZGVzKSB7XG4gICAgICBkb3RJbmRleGVzLnB1c2goaSk7XG4gICAgfVxuICAgIHJldHVybiBkb3RJbmRleGVzO1xuICB9XG4gIGlmIChjZWxsQWxpZ24gPT09IFwiY2VudGVyXCIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlQ291bnQgLSAxOyBpICs9IHNjcm9sbFNsaWRlcykge1xuICAgICAgZG90SW5kZXhlcy5wdXNoKGkpO1xuICAgIH1cbiAgICBpZiAoc2xpZGVDb3VudCA+IDApIHtcbiAgICAgIGRvdEluZGV4ZXMucHVzaChzbGlkZUNvdW50IC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBkb3RJbmRleGVzO1xuICB9XG4gIGlmIChjZWxsQWxpZ24gPT09IFwibGVmdFwiKSB7XG4gICAgaWYgKHNsaWRlc1RvU2hvdyA+PSBzbGlkZUNvdW50KSB7XG4gICAgICByZXR1cm4gWzBdO1xuICAgIH1cbiAgICBjb25zdCBsYXN0UG9zc2libGVJbmRleFdpdGhvdXRXaGl0ZXNwYWNlID0gc2xpZGVDb3VudCAtIHNsaWRlc1RvU2hvdztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RQb3NzaWJsZUluZGV4V2l0aG91dFdoaXRlc3BhY2U7IGkgKz0gc2Nyb2xsU2xpZGVzKSB7XG4gICAgICBkb3RJbmRleGVzLnB1c2goaSk7XG4gICAgfVxuICAgIGlmIChzY3JvbGxNb2RlID09PSBcInJlbWFpbmRlclwiIC8qIHJlbWFpbmRlciAqLykge1xuICAgICAgZG90SW5kZXhlcy5wdXNoKGxhc3RQb3NzaWJsZUluZGV4V2l0aG91dFdoaXRlc3BhY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb3RJbmRleGVzLnB1c2goZG90SW5kZXhlc1tkb3RJbmRleGVzLmxlbmd0aCAtIDFdICsgc2Nyb2xsU2xpZGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvdEluZGV4ZXM7XG4gIH1cbiAgaWYgKGNlbGxBbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgaWYgKHNsaWRlc1RvU2hvdyA+PSBzbGlkZUNvdW50KSB7XG4gICAgICByZXR1cm4gW3NsaWRlQ291bnQgLSAxXTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb3NzaWJsZUluZGV4V2l0aG91dFdoaXRlc3BhY2UgPSBzbGlkZXNUb1Nob3cgLSAxO1xuICAgIGlmIChzY3JvbGxNb2RlID09PSBcInJlbWFpbmRlclwiIC8qIHJlbWFpbmRlciAqLykge1xuICAgICAgZm9yIChsZXQgaSA9IGZpcnN0UG9zc2libGVJbmRleFdpdGhvdXRXaGl0ZXNwYWNlOyBpIDwgc2xpZGVDb3VudCAtIDE7IGkgKz0gc2Nyb2xsU2xpZGVzKSB7XG4gICAgICAgIGRvdEluZGV4ZXMucHVzaChpKTtcbiAgICAgIH1cbiAgICAgIGRvdEluZGV4ZXMucHVzaChzbGlkZUNvdW50IC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSBzbGlkZUNvdW50IC0gMTsgaSA+IGZpcnN0UG9zc2libGVJbmRleFdpdGhvdXRXaGl0ZXNwYWNlOyBpIC09IHNjcm9sbFNsaWRlcykge1xuICAgICAgICBkb3RJbmRleGVzLnB1c2goaSk7XG4gICAgICB9XG4gICAgICBkb3RJbmRleGVzLnB1c2goZG90SW5kZXhlc1tkb3RJbmRleGVzLmxlbmd0aCAtIDFdIC0gc2Nyb2xsU2xpZGVzKTtcbiAgICAgIGRvdEluZGV4ZXMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gZG90SW5kZXhlcztcbiAgfVxuICByZXR1cm4gZG90SW5kZXhlcztcbn07XG52YXIgUGFnaW5nRG90cyA9ICh7XG4gIHBhZ2luZ0RvdHNJbmRpY2VzLFxuICBkZWZhdWx0Q29udHJvbHNDb25maWc6IHtcbiAgICBwYWdpbmdEb3RzQ29udGFpbmVyQ2xhc3NOYW1lLFxuICAgIHBhZ2luZ0RvdHNDbGFzc05hbWUsXG4gICAgcGFnaW5nRG90c1N0eWxlID0ge30sXG4gICAgcGFnaW5nRG90c09uQ2xpY2tcbiAgfSxcbiAgY2Fyb3VzZWxJZCxcbiAgY3VycmVudFNsaWRlLFxuICBvblVzZXJOYXZpZ2F0aW9uLFxuICBzbGlkZUNvdW50LFxuICBnb1RvU2xpZGUsXG4gIHRhYmJlZFxufSkgPT4ge1xuICBjb25zdCBsaXN0U3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgdG9wOiAtMTAsXG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgbWFyZ2luOiAwLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgbGlzdFN0eWxlVHlwZTogXCJub25lXCJcbiAgfTtcbiAgY29uc3QgZ2V0QnV0dG9uU3R5bGVzID0gdXNlQ2FsbGJhY2soXG4gICAgKGFjdGl2ZSkgPT4gKHtcbiAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICBvcGFjaXR5OiBhY3RpdmUgPyAxIDogMC41LFxuICAgICAgYmFja2dyb3VuZDogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pLFxuICAgIFtdXG4gICk7XG4gIGNvbnN0IGN1cnJlbnRTbGlkZUJvdW5kZWQgPSBnZXRCb3VuZGVkSW5kZXgoY3VycmVudFNsaWRlLCBzbGlkZUNvdW50KTtcbiAgaWYgKCF0YWJiZWQpXG4gICAgcmV0dXJuIG51bGw7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogcGFnaW5nRG90c0NvbnRhaW5lckNsYXNzTmFtZSxcbiAgICAgIHN0eWxlOiBsaXN0U3R5bGVzLFxuICAgICAgcm9sZTogXCJ0YWJsaXN0XCIsXG4gICAgICBcImFyaWEtbGFiZWxcIjogXCJDaG9vc2Ugc2xpZGUgdG8gZGlzcGxheS5cIixcbiAgICAgIGNoaWxkcmVuOiBwYWdpbmdEb3RzSW5kaWNlcy5tYXAoKHNsaWRlSW5kZXgsIGkpID0+IHtcbiAgICAgICAgY29uc3QgaXNBY3RpdmUgPSBjdXJyZW50U2xpZGVCb3VuZGVkID09PSBzbGlkZUluZGV4IHx8IC8vIHNldHMgbmF2aWdhdGlvbiBkb3RzIGFjdGl2ZSBpZiB0aGUgY3VycmVudCBzbGlkZSBmYWxscyBpbiB0aGUgY3VycmVudCBpbmRleCByYW5nZVxuICAgICAgICBjdXJyZW50U2xpZGVCb3VuZGVkIDwgc2xpZGVJbmRleCAmJiAoaSA9PT0gMCB8fCBjdXJyZW50U2xpZGVCb3VuZGVkID4gcGFnaW5nRG90c0luZGljZXNbaSAtIDFdKTtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzKFxuICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgIFwicGFnaW5nLWl0ZW1cIixcbiAgICAgICAgICAgICAgcGFnaW5nRG90c0NsYXNzTmFtZSxcbiAgICAgICAgICAgICAgaXNBY3RpdmUgPyBcImFjdGl2ZVwiIDogbnVsbFxuICAgICAgICAgICAgXS5qb2luKFwiIFwiKSxcbiAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBzdHlsZTogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGdldEJ1dHRvblN0eWxlcyhpc0FjdGl2ZSkpLCBwYWdpbmdEb3RzU3R5bGUpLFxuICAgICAgICAgICAgb25DbGljazogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIHBhZ2luZ0RvdHNPbkNsaWNrID09IG51bGwgPyB2b2lkIDAgOiBwYWdpbmdEb3RzT25DbGljayhldmVudCk7XG4gICAgICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgb25Vc2VyTmF2aWdhdGlvbihldmVudCk7XG4gICAgICAgICAgICAgIGdvVG9TbGlkZShzbGlkZUluZGV4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogYHNsaWRlICR7c2xpZGVJbmRleCArIDF9YCxcbiAgICAgICAgICAgIFwiYXJpYS1zZWxlY3RlZFwiOiBpc0FjdGl2ZSxcbiAgICAgICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBgJHtjYXJvdXNlbElkfS1zbGlkZS0ke3NsaWRlSW5kZXggKyAxfWAsXG4gICAgICAgICAgICByb2xlOiBcInRhYlwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzKFxuICAgICAgICAgICAgICBcInN2Z1wiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcInBhZ2luZy1kb3RcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogXCI2XCIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjZcIixcbiAgICAgICAgICAgICAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgICAgIGZvY3VzYWJsZTogXCJmYWxzZVwiLFxuICAgICAgICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIDYgNlwiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MyhcImNpcmNsZVwiLCB7IGN4OiBcIjNcIiwgY3k6IFwiM1wiLCByOiBcIjNcIiB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzbGlkZUluZGV4XG4gICAgICAgICk7XG4gICAgICB9KVxuICAgIH1cbiAgKTtcbn07XG5cbi8vIHNyYy9ob29rcy91c2UtdHdlZW4udHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QzLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIsIHVzZVJlZiBhcyB1c2VSZWYzIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlVHdlZW4gPSAoZHVyYXRpb25NcywgZWFzaW5nRnVuY3Rpb24sIG5hdmlnYXRpb25OdW0sIHNob3VsZEludGVycnVwdCkgPT4ge1xuICBjb25zdCBbbm9ybWFsaXplZFRpbWVSYXcsIHNldE5vcm1hbGl6ZWRUaW1lXSA9IHVzZVN0YXRlMigxKTtcbiAgY29uc3Qgc3RhcnRUaW1lID0gdXNlUmVmMyhEYXRlLm5vdygpKTtcbiAgY29uc3QgckFGID0gdXNlUmVmMygpO1xuICBjb25zdCBpc0ZpcnN0UmVuZGVyID0gdXNlUmVmMyh0cnVlKTtcbiAgY29uc3QgbGFzdE5hdmlnYXRpb25OdW0gPSB1c2VSZWYzKG51bGwpO1xuICBjb25zdCBub3JtYWxpemVkVGltZSA9IGxhc3ROYXZpZ2F0aW9uTnVtLmN1cnJlbnQgPT09IG51bGwgfHwgbGFzdE5hdmlnYXRpb25OdW0uY3VycmVudCA9PT0gbmF2aWdhdGlvbk51bSB8fCBzaG91bGRJbnRlcnJ1cHQgPyBub3JtYWxpemVkVGltZVJhdyA6IDA7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGxhc3ROYXZpZ2F0aW9uTnVtLmN1cnJlbnQgPSBuYXZpZ2F0aW9uTnVtO1xuICAgIGlmIChpc0ZpcnN0UmVuZGVyLmN1cnJlbnQpIHtcbiAgICAgIGlzRmlyc3RSZW5kZXIuY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkSW50ZXJydXB0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXJ0VGltZS5jdXJyZW50ID0gRGF0ZS5ub3coKTtcbiAgICBzZXROb3JtYWxpemVkVGltZSgwKTtcbiAgICBjb25zdCB0aWNrID0gKCkgPT4ge1xuICAgICAgckFGLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUaW1lMiA9IE1hdGgubWluKFxuICAgICAgICAgIDEsXG4gICAgICAgICAgKGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lLmN1cnJlbnQpIC8gZHVyYXRpb25Nc1xuICAgICAgICApO1xuICAgICAgICBzZXROb3JtYWxpemVkVGltZShub3JtYWxpemVkVGltZTIpO1xuICAgICAgICBpZiAobm9ybWFsaXplZFRpbWUyIDwgMSkge1xuICAgICAgICAgIHRpY2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByQUYuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aWNrKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChyQUYuY3VycmVudCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJBRi5jdXJyZW50KTtcbiAgICAgICAgc2V0Tm9ybWFsaXplZFRpbWUoMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW25hdmlnYXRpb25OdW0sIGR1cmF0aW9uTXMsIHNob3VsZEludGVycnVwdF0pO1xuICByZXR1cm4ge1xuICAgIGlzQW5pbWF0aW5nOiBub3JtYWxpemVkVGltZSAhPT0gMSxcbiAgICB2YWx1ZTogZWFzaW5nRnVuY3Rpb24obm9ybWFsaXplZFRpbWUpXG4gIH07XG59O1xuXG4vLyBzcmMvc2xpZGVyLWxpc3QudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4NCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIGdldFBlcmNlbnRPZmZzZXRGb3JTbGlkZSA9IChjdXJyZW50U2xpZGUsIHNsaWRlQ291bnQsIHNsaWRlc1RvU2hvdywgY2VsbEFsaWduLCB3cmFwQXJvdW5kKSA9PiB7XG4gIGNvbnN0IHJlbmRlcmVkU2xpZGVDb3VudCA9IHdyYXBBcm91bmQgPyAzICogc2xpZGVDb3VudCA6IHNsaWRlQ291bnQ7XG4gIGNvbnN0IHNpbmdsZVNsaWRlUGVyY2VudE9mV2hvbGUgPSAxMDAgLyByZW5kZXJlZFNsaWRlQ291bnQ7XG4gIGxldCBzbGlkZTBPZmZzZXQgPSB3cmFwQXJvdW5kID8gLTEwMCAvIDMgOiAwO1xuICBpZiAoY2VsbEFsaWduID09PSBcInJpZ2h0XCIgJiYgc2xpZGVzVG9TaG93ID4gMSkge1xuICAgIGNvbnN0IGV4Y2Vzc1NsaWRlcyA9IHNsaWRlc1RvU2hvdyAtIDE7XG4gICAgc2xpZGUwT2Zmc2V0ICs9IHNpbmdsZVNsaWRlUGVyY2VudE9mV2hvbGUgKiBleGNlc3NTbGlkZXM7XG4gIH1cbiAgaWYgKGNlbGxBbGlnbiA9PT0gXCJjZW50ZXJcIiAmJiBzbGlkZXNUb1Nob3cgPiAxKSB7XG4gICAgY29uc3QgZXhjZXNzU2xpZGVzID0gc2xpZGVzVG9TaG93IC0gMTtcbiAgICBjb25zdCBleGNlc3NMZWZ0U2xpZGVzID0gZXhjZXNzU2xpZGVzIC8gMjtcbiAgICBzbGlkZTBPZmZzZXQgKz0gc2luZ2xlU2xpZGVQZXJjZW50T2ZXaG9sZSAqIGV4Y2Vzc0xlZnRTbGlkZXM7XG4gIH1cbiAgY29uc3QgY3VycmVudFNsaWRlT2Zmc2V0RnJvbTAgPSAxMDAgLyByZW5kZXJlZFNsaWRlQ291bnQgKiBjdXJyZW50U2xpZGU7XG4gIHJldHVybiBzbGlkZTBPZmZzZXQgLSBjdXJyZW50U2xpZGVPZmZzZXRGcm9tMDtcbn07XG52YXIgU2xpZGVyTGlzdCA9IFJlYWN0My5mb3J3YXJkUmVmKFxuICAoe1xuICAgIGFuaW1hdGlvbixcbiAgICBhbmltYXRpb25EaXN0YW5jZSxcbiAgICBjZWxsQWxpZ24sXG4gICAgY2hpbGRyZW4sXG4gICAgY3VycmVudFNsaWRlLFxuICAgIGRpc2FibGVBbmltYXRpb24sXG4gICAgZGlzYWJsZUVkZ2VTd2lwaW5nLFxuICAgIGRyYWdnZWRPZmZzZXQsXG4gICAgZWFzaW5nLFxuICAgIGVkZ2VFYXNpbmcsXG4gICAgaXNEcmFnZ2luZyxcbiAgICBzY3JvbGxNb2RlLFxuICAgIHNsaWRlQ291bnQsXG4gICAgc2xpZGVzVG9TY3JvbGwsXG4gICAgc2xpZGVzVG9TaG93LFxuICAgIHNwZWVkLFxuICAgIHdyYXBBcm91bmQsXG4gICAgc2xpZGVXaWR0aCxcbiAgICBzZXRJc0FuaW1hdGluZ1xuICB9LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCByZW5kZXJlZFNsaWRlQ291bnQgPSB3cmFwQXJvdW5kID8gMyAqIHNsaWRlQ291bnQgOiBzbGlkZUNvdW50O1xuICAgIGNvbnN0IGxpc3RWaXNpYmxlV2lkdGggPSBzbGlkZVdpZHRoID8gYGNhbGMoJHtzbGlkZVdpZHRofSAqICR7cmVuZGVyZWRTbGlkZUNvdW50fSlgIDogYCR7cmVuZGVyZWRTbGlkZUNvdW50ICogMTAwIC8gc2xpZGVzVG9TaG93fSVgO1xuICAgIGNvbnN0IHBlcmNlbnRPZmZzZXRGb3JTbGlkZVByb3BzID0gW1xuICAgICAgc2xpZGVDb3VudCxcbiAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgIGNlbGxBbGlnbixcbiAgICAgIHdyYXBBcm91bmRcbiAgICBdO1xuICAgIGNvbnN0IGRvdEluZGV4ZXMgPSBnZXREb3RJbmRleGVzKFxuICAgICAgc2xpZGVDb3VudCxcbiAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgIHdyYXBBcm91bmQsXG4gICAgICBjZWxsQWxpZ25cbiAgICApO1xuICAgIGxldCBjbGFtcGVkRHJhZ2dlZE9mZnNldCA9IGAke2RyYWdnZWRPZmZzZXR9cHhgO1xuICAgIGlmIChpc0RyYWdnaW5nICYmIGRpc2FibGVFZGdlU3dpcGluZyAmJiAhd3JhcEFyb3VuZCkge1xuICAgICAgY29uc3QgY2xhbXBPZmZzZXRzID0gW1xuICAgICAgICBkb3RJbmRleGVzWzBdLFxuICAgICAgICBkb3RJbmRleGVzW2RvdEluZGV4ZXMubGVuZ3RoIC0gMV1cbiAgICAgIF0ubWFwKFxuICAgICAgICAoaW5kZXgpID0+IGdldFBlcmNlbnRPZmZzZXRGb3JTbGlkZShpbmRleCwgLi4ucGVyY2VudE9mZnNldEZvclNsaWRlUHJvcHMpXG4gICAgICApO1xuICAgICAgY2xhbXBlZERyYWdnZWRPZmZzZXQgPSBgY2xhbXAoJHtjbGFtcE9mZnNldHNbMV19JSwgJHtkcmFnZ2VkT2Zmc2V0fXB4LCAke2NsYW1wT2Zmc2V0c1swXX0lKWA7XG4gICAgfVxuICAgIGNvbnN0IHNsaWRlQmFzZWRPZmZzZXQgPSBnZXRQZXJjZW50T2Zmc2V0Rm9yU2xpZGUoXG4gICAgICBjdXJyZW50U2xpZGUsXG4gICAgICAuLi5wZXJjZW50T2Zmc2V0Rm9yU2xpZGVQcm9wc1xuICAgICk7XG4gICAgY29uc3QgaXNFZGdlRWFzaW5nID0gIWRpc2FibGVFZGdlU3dpcGluZyAmJiAhd3JhcEFyb3VuZCAmJiAoY3VycmVudFNsaWRlID09PSBkb3RJbmRleGVzWzBdICYmIGFuaW1hdGlvbkRpc3RhbmNlIDwgMCB8fCBjdXJyZW50U2xpZGUgPT09IGRvdEluZGV4ZXNbZG90SW5kZXhlcy5sZW5ndGggLSAxXSAmJiBhbmltYXRpb25EaXN0YW5jZSA+IDApO1xuICAgIGNvbnN0IHsgdmFsdWU6IHRyYW5zaXRpb24sIGlzQW5pbWF0aW5nIH0gPSB1c2VUd2VlbihcbiAgICAgIHNwZWVkLFxuICAgICAgIWlzRWRnZUVhc2luZyA/IGVhc2luZyA6IGVkZ2VFYXNpbmcsXG4gICAgICAvLyBhbmltYXRpb25EaXN0YW5jZSBpcyBhc3N1bWVkIHRvIGJlIHVuaXF1ZSBlbm91Z2ggdGhhdCBpdCBjYW4gYmUgdXNlZCB0b1xuICAgICAgLy8gZGV0ZWN0IHdoZW4gYSBuZXcgYW5pbWF0aW9uIHNob3VsZCBzdGFydC4gVGhpcyBpcyB1c2VkIGluIGFkZGl0aW9uIHRvXG4gICAgICAvLyBjdXJyZW50U2xpZGUgYmVjYXVzZSBzb21lIGFuaW1hdGlvbnMsIHN1Y2ggYXMgdGhvc2Ugd2l0aCBlZGdlRWFzaW5nLCBkb1xuICAgICAgLy8gbm90IG9jY3VyIGR1ZSB0byBhIGNoYW5nZSBpbiB2YWx1ZSBvZiBjdXJyZW50U2xpZGVcbiAgICAgIGN1cnJlbnRTbGlkZSArIGFuaW1hdGlvbkRpc3RhbmNlLFxuICAgICAgaXNEcmFnZ2luZyB8fCBkaXNhYmxlQW5pbWF0aW9uIHx8IGFuaW1hdGlvbiA9PT0gXCJmYWRlXCJcbiAgICApO1xuICAgIGxldCBwb3NpdGlvbmluZztcbiAgICBpZiAoaXNEcmFnZ2luZyB8fCBzbGlkZUJhc2VkT2Zmc2V0ICE9PSAwIHx8IGlzQW5pbWF0aW5nKSB7XG4gICAgICBpZiAoaXNEcmFnZ2luZykge1xuICAgICAgICBwb3NpdGlvbmluZyA9IGB0cmFuc2xhdGVYKCR7Y2xhbXBlZERyYWdnZWRPZmZzZXR9KWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0cmFuc2l0aW9uT2Zmc2V0ID0gaXNBbmltYXRpbmcgPyAoMSAtIHRyYW5zaXRpb24pICogYW5pbWF0aW9uRGlzdGFuY2UgOiAwO1xuICAgICAgICBwb3NpdGlvbmluZyA9IGB0cmFuc2xhdGVYKGNhbGMoJHtzbGlkZUJhc2VkT2Zmc2V0fSUgLSAke3RyYW5zaXRpb25PZmZzZXR9cHgpKWA7XG4gICAgICB9XG4gICAgfVxuICAgIHVzZUVmZmVjdDQoKCkgPT4ge1xuICAgICAgc2V0SXNBbmltYXRpbmcoaXNBbmltYXRpbmcpO1xuICAgIH0sIFtpc0FuaW1hdGluZywgc2V0SXNBbmltYXRpbmddKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDQoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAgICAgY2xhc3NOYW1lOiBcInNsaWRlci1saXN0XCIsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgd2lkdGg6IGxpc3RWaXNpYmxlV2lkdGgsXG4gICAgICAgICAgdGV4dEFsaWduOiBcImxlZnRcIixcbiAgICAgICAgICB1c2VyU2VsZWN0OiBcImF1dG9cIixcbiAgICAgICAgICB0cmFuc2Zvcm06IHBvc2l0aW9uaW5nLFxuICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9XG4gICAgKTtcbiAgfVxuKTtcblNsaWRlckxpc3QuZGlzcGxheU5hbWUgPSBcIlNsaWRlckxpc3RcIjtcblxuLy8gc3JjL2NvbnRyb2xzLnRzeFxuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2NvbnRyb2wtc3R5bGVzLnRzXG52YXIgY29tbW9uU3R5bGVzID0ge1xuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICBkaXNwbGF5OiBcImZsZXhcIixcbiAgekluZGV4OiAxLFxuICB0b3A6IDAsXG4gIGxlZnQ6IDAsXG4gIGJvdHRvbTogMCxcbiAgcmlnaHQ6IDBcbn07XG52YXIgZ2V0Q29udHJvbENvbnRhaW5lckZsZXhTdHlsZXMgPSAocG9zKSA9PiB7XG4gIGxldCBhbGlnbkl0ZW1zO1xuICBzd2l0Y2ggKHBvcykge1xuICAgIGNhc2UgXCJUb3BMZWZ0XCIgLyogVG9wTGVmdCAqLzpcbiAgICBjYXNlIFwiVG9wQ2VudGVyXCIgLyogVG9wQ2VudGVyICovOlxuICAgIGNhc2UgXCJUb3BSaWdodFwiIC8qIFRvcFJpZ2h0ICovOlxuICAgICAgYWxpZ25JdGVtcyA9IFwiZmxleC1zdGFydFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkNlbnRlckxlZnRcIiAvKiBDZW50ZXJMZWZ0ICovOlxuICAgIGNhc2UgXCJDZW50ZXJDZW50ZXJcIiAvKiBDZW50ZXJDZW50ZXIgKi86XG4gICAgY2FzZSBcIkNlbnRlclJpZ2h0XCIgLyogQ2VudGVyUmlnaHQgKi86XG4gICAgICBhbGlnbkl0ZW1zID0gXCJjZW50ZXJcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJCb3R0b21MZWZ0XCIgLyogQm90dG9tTGVmdCAqLzpcbiAgICBjYXNlIFwiQm90dG9tQ2VudGVyXCIgLyogQm90dG9tQ2VudGVyICovOlxuICAgIGNhc2UgXCJCb3R0b21SaWdodFwiIC8qIEJvdHRvbVJpZ2h0ICovOlxuICAgICAgYWxpZ25JdGVtcyA9IFwiZmxleC1lbmRcIjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGxldCBqdXN0aWZ5Q29udGVudDtcbiAgc3dpdGNoIChwb3MpIHtcbiAgICBjYXNlIFwiVG9wTGVmdFwiIC8qIFRvcExlZnQgKi86XG4gICAgY2FzZSBcIkNlbnRlckxlZnRcIiAvKiBDZW50ZXJMZWZ0ICovOlxuICAgIGNhc2UgXCJCb3R0b21MZWZ0XCIgLyogQm90dG9tTGVmdCAqLzpcbiAgICAgIGp1c3RpZnlDb250ZW50ID0gXCJmbGV4LXN0YXJ0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiVG9wQ2VudGVyXCIgLyogVG9wQ2VudGVyICovOlxuICAgIGNhc2UgXCJDZW50ZXJDZW50ZXJcIiAvKiBDZW50ZXJDZW50ZXIgKi86XG4gICAgY2FzZSBcIkJvdHRvbUNlbnRlclwiIC8qIEJvdHRvbUNlbnRlciAqLzpcbiAgICAgIGp1c3RpZnlDb250ZW50ID0gXCJjZW50ZXJcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJUb3BSaWdodFwiIC8qIFRvcFJpZ2h0ICovOlxuICAgIGNhc2UgXCJDZW50ZXJSaWdodFwiIC8qIENlbnRlclJpZ2h0ICovOlxuICAgIGNhc2UgXCJCb3R0b21SaWdodFwiIC8qIEJvdHRvbVJpZ2h0ICovOlxuICAgICAganVzdGlmeUNvbnRlbnQgPSBcImZsZXgtZW5kXCI7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4geyBhbGlnbkl0ZW1zLCBqdXN0aWZ5Q29udGVudCB9O1xufTtcbnZhciBnZXRDb250cm9sQ29udGFpbmVyU3R5bGVzID0gKHBvcykgPT4ge1xuICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGdldENvbnRyb2xDb250YWluZXJGbGV4U3R5bGVzKHBvcykpLCBjb21tb25TdHlsZXMpO1xufTtcblxuLy8gc3JjL2NvbnRyb2xzLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDUgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBjb250cm9sc01hcCA9IFtcbiAgeyBmdW5jTmFtZTogXCJyZW5kZXJUb3BMZWZ0Q29udHJvbHNcIiwga2V5OiBcIlRvcExlZnRcIiAvKiBUb3BMZWZ0ICovIH0sXG4gIHsgZnVuY05hbWU6IFwicmVuZGVyVG9wQ2VudGVyQ29udHJvbHNcIiwga2V5OiBcIlRvcENlbnRlclwiIC8qIFRvcENlbnRlciAqLyB9LFxuICB7IGZ1bmNOYW1lOiBcInJlbmRlclRvcFJpZ2h0Q29udHJvbHNcIiwga2V5OiBcIlRvcFJpZ2h0XCIgLyogVG9wUmlnaHQgKi8gfSxcbiAgeyBmdW5jTmFtZTogXCJyZW5kZXJDZW50ZXJMZWZ0Q29udHJvbHNcIiwga2V5OiBcIkNlbnRlckxlZnRcIiAvKiBDZW50ZXJMZWZ0ICovIH0sXG4gIHsgZnVuY05hbWU6IFwicmVuZGVyQ2VudGVyQ2VudGVyQ29udHJvbHNcIiwga2V5OiBcIkNlbnRlckNlbnRlclwiIC8qIENlbnRlckNlbnRlciAqLyB9LFxuICB7IGZ1bmNOYW1lOiBcInJlbmRlckNlbnRlclJpZ2h0Q29udHJvbHNcIiwga2V5OiBcIkNlbnRlclJpZ2h0XCIgLyogQ2VudGVyUmlnaHQgKi8gfSxcbiAgeyBmdW5jTmFtZTogXCJyZW5kZXJCb3R0b21MZWZ0Q29udHJvbHNcIiwga2V5OiBcIkJvdHRvbUxlZnRcIiAvKiBCb3R0b21MZWZ0ICovIH0sXG4gIHsgZnVuY05hbWU6IFwicmVuZGVyQm90dG9tQ2VudGVyQ29udHJvbHNcIiwga2V5OiBcIkJvdHRvbUNlbnRlclwiIC8qIEJvdHRvbUNlbnRlciAqLyB9LFxuICB7IGZ1bmNOYW1lOiBcInJlbmRlckJvdHRvbVJpZ2h0Q29udHJvbHNcIiwga2V5OiBcIkJvdHRvbVJpZ2h0XCIgLyogQm90dG9tUmlnaHQgKi8gfVxuXTtcbnZhciByZW5kZXJDb250cm9scyA9IChwcm9wcywgc2xpZGVDb3VudCwgY3VycmVudFNsaWRlLCBnb1RvU2xpZGUsIG5leHRTbGlkZSwgcHJldlNsaWRlLCBzbGlkZXNUb1Njcm9sbCkgPT4ge1xuICBpZiAocHJvcHMud2l0aG91dENvbnRyb2xzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZGlzYWJsZUNoZWNrUHJvcHMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9wcyksIHtcbiAgICBjdXJyZW50U2xpZGUsXG4gICAgc2xpZGVDb3VudFxuICB9KTtcbiAgY29uc3QgbmV4dERpc2FibGVkID0gbmV4dEJ1dHRvbkRpc2FibGVkKGRpc2FibGVDaGVja1Byb3BzKTtcbiAgY29uc3QgcHJldmlvdXNEaXNhYmxlZCA9IHByZXZCdXR0b25EaXNhYmxlZChkaXNhYmxlQ2hlY2tQcm9wcyk7XG4gIGNvbnN0IHBhZ2luZ0RvdHNJbmRpY2VzID0gZ2V0RG90SW5kZXhlcyhcbiAgICBzbGlkZUNvdW50LFxuICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgIHByb3BzLnNjcm9sbE1vZGUsXG4gICAgcHJvcHMuc2xpZGVzVG9TaG93LFxuICAgIHByb3BzLndyYXBBcm91bmQsXG4gICAgcHJvcHMuY2VsbEFsaWduXG4gICk7XG4gIHJldHVybiBjb250cm9sc01hcC5tYXAoKGNvbnRyb2wpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFwcm9wc1tjb250cm9sLmZ1bmNOYW1lXSB8fCB0eXBlb2YgcHJvcHNbY29udHJvbC5mdW5jTmFtZV0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g1KEZyYWdtZW50LCB7fSwgY29udHJvbC5mdW5jTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NShcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBnZXRDb250cm9sQ29udGFpbmVyU3R5bGVzKGNvbnRyb2wua2V5KSksIHtcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgICAgICB9KSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3g1KFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgIGBzbGlkZXItY29udHJvbC0ke2NvbnRyb2wua2V5LnRvTG93ZXJDYXNlKCl9YCxcbiAgICAgICAgICAgICAgcHJvcHMuZGVmYXVsdENvbnRyb2xzQ29uZmlnLmNvbnRhaW5lckNsYXNzTmFtZSB8fCBcIlwiXG4gICAgICAgICAgICBdLmpvaW4oXCIgXCIpLnRyaW0oKSxcbiAgICAgICAgICAgIHN0eWxlOiB7IHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiIH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogKF9hID0gcHJvcHNbY29udHJvbC5mdW5jTmFtZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHByb3BzLCB7XG4gICAgICAgICAgICAgIGNlbGxBbGlnbjogcHJvcHMuY2VsbEFsaWduLFxuICAgICAgICAgICAgICBjZWxsU3BhY2luZzogcHJvcHMuY2VsbFNwYWNpbmcsXG4gICAgICAgICAgICAgIGN1cnJlbnRTbGlkZSxcbiAgICAgICAgICAgICAgZGVmYXVsdENvbnRyb2xzQ29uZmlnOiBwcm9wcy5kZWZhdWx0Q29udHJvbHNDb25maWcgfHwge30sXG4gICAgICAgICAgICAgIGNhcm91c2VsSWQ6IHByb3BzLmNhcm91c2VsSWQsXG4gICAgICAgICAgICAgIHBhZ2luZ0RvdHNJbmRpY2VzLFxuICAgICAgICAgICAgICBnb1RvU2xpZGUsXG4gICAgICAgICAgICAgIG5leHREaXNhYmxlZCxcbiAgICAgICAgICAgICAgbmV4dFNsaWRlLFxuICAgICAgICAgICAgICBvblVzZXJOYXZpZ2F0aW9uOiBwcm9wcy5vblVzZXJOYXZpZ2F0aW9uLFxuICAgICAgICAgICAgICBwcmV2aW91c0Rpc2FibGVkLFxuICAgICAgICAgICAgICBwcmV2aW91c1NsaWRlOiBwcmV2U2xpZGUsXG4gICAgICAgICAgICAgIHNjcm9sbE1vZGU6IHByb3BzLnNjcm9sbE1vZGUsXG4gICAgICAgICAgICAgIHNsaWRlQ291bnQsXG4gICAgICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgICAgICAgICBzbGlkZXNUb1Nob3c6IHByb3BzLnNsaWRlc1RvU2hvdyB8fCAxLFxuICAgICAgICAgICAgICB0YWJiZWQ6IHByb3BzLnRhYmJlZCxcbiAgICAgICAgICAgICAgdmVydGljYWw6IHByb3BzLnZlcnRpY2FsLFxuICAgICAgICAgICAgICB3cmFwQXJvdW5kOiBwcm9wcy53cmFwQXJvdW5kXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGNvbnRyb2wuZnVuY05hbWVcbiAgICApO1xuICB9KTtcbn07XG52YXIgY29udHJvbHNfZGVmYXVsdCA9IHJlbmRlckNvbnRyb2xzO1xuXG4vLyBzcmMvZGVmYXVsdC1jYXJvdXNlbC1wcm9wcy50c3hcbmltcG9ydCB7IEZyYWdtZW50IGFzIEZyYWdtZW50MiwganN4IGFzIGpzeDYgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBlYXNlT3V0ID0gKHQpID0+IF9fcG93KHQgLSAxLCAzKSArIDE7XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBhZGFwdGl2ZUhlaWdodDogZmFsc2UsXG4gIGFkYXB0aXZlSGVpZ2h0QW5pbWF0aW9uOiB0cnVlLFxuICBhZnRlclNsaWRlOiAoKSA9PiB7XG4gIH0sXG4gIGF1dG9wbGF5OiBmYWxzZSxcbiAgYXV0b3BsYXlJbnRlcnZhbDogM2UzLFxuICBhdXRvcGxheVJldmVyc2U6IGZhbHNlLFxuICBiZWZvcmVTbGlkZTogKCkgPT4ge1xuICB9LFxuICBjZWxsQWxpZ246IFwibGVmdFwiLFxuICBjZWxsU3BhY2luZzogMCxcbiAgZGVmYXVsdENvbnRyb2xzQ29uZmlnOiB7fSxcbiAgZGlzYWJsZUFuaW1hdGlvbjogZmFsc2UsXG4gIGRpc2FibGVFZGdlU3dpcGluZzogZmFsc2UsXG4gIGRyYWdnaW5nOiB0cnVlLFxuICBkcmFnVGhyZXNob2xkOiAwLjUsXG4gIGVhc2luZzogZWFzZU91dCxcbiAgZWRnZUVhc2luZzogZWFzZU91dCxcbiAgZW5hYmxlS2V5Ym9hcmRDb250cm9sczogZmFsc2UsXG4gIGZyYW1lQXJpYUxhYmVsOiBcIlNsaWRlclwiLFxuICBrZXlDb2RlQ29uZmlnOiB7XG4gICAgbmV4dFNsaWRlOiBbMzksIDY4LCAzOCwgODddLFxuICAgIHByZXZpb3VzU2xpZGU6IFszNywgNjUsIDQwLCA4M10sXG4gICAgZmlyc3RTbGlkZTogWzgxXSxcbiAgICBsYXN0U2xpZGU6IFs2OV0sXG4gICAgcGF1c2U6IFszMl1cbiAgfSxcbiAgbGFuZG1hcms6IGZhbHNlLFxuICBvbkRyYWdTdGFydDogKCkgPT4ge1xuICB9LFxuICBvbkRyYWc6ICgpID0+IHtcbiAgfSxcbiAgb25EcmFnRW5kOiAoKSA9PiB7XG4gIH0sXG4gIG9uVXNlck5hdmlnYXRpb246ICgpID0+IHtcbiAgfSxcbiAgcGF1c2VPbkhvdmVyOiB0cnVlLFxuICByZW5kZXJBbm5vdW5jZVNsaWRlTWVzc2FnZTogZGVmYXVsdFJlbmRlckFubm91bmNlU2xpZGVNZXNzYWdlLFxuICByZW5kZXJCb3R0b21DZW50ZXJDb250cm9sczogKHByb3BzKSA9PiAvKiBAX19QVVJFX18gKi8ganN4NihQYWdpbmdEb3RzLCBfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpKSxcbiAgcmVuZGVyQ2VudGVyTGVmdENvbnRyb2xzOiAocHJvcHMpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3g2KFByZXZpb3VzQnV0dG9uLCBfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpKSxcbiAgcmVuZGVyQ2VudGVyUmlnaHRDb250cm9sczogKHByb3BzKSA9PiAvKiBAX19QVVJFX18gKi8ganN4NihOZXh0QnV0dG9uLCBfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpKSxcbiAgc2Nyb2xsTW9kZTogXCJwYWdlXCIgLyogcGFnZSAqLyxcbiAgc2xpZGVzVG9TY3JvbGw6IDEsXG4gIHNsaWRlc1RvU2hvdzogMSxcbiAgc3BlZWQ6IDUwMCxcbiAgc3R5bGU6IHt9LFxuICBzd2lwaW5nOiB0cnVlLFxuICB0YWJiZWQ6IHRydWUsXG4gIHZlcnRpY2FsOiBmYWxzZSxcbiAgd2l0aG91dENvbnRyb2xzOiBmYWxzZSxcbiAgd3JhcEFyb3VuZDogZmFsc2UsXG4gIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4NihGcmFnbWVudDIsIHt9KVxufTtcbnZhciBkZWZhdWx0X2Nhcm91c2VsX3Byb3BzX2RlZmF1bHQgPSBkZWZhdWx0UHJvcHM7XG5cbi8vIHNyYy9ob29rcy91c2UtZnJhbWUtaGVpZ2h0LnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazMsIHVzZU1lbW8sIHVzZVN0YXRlIGFzIHVzZVN0YXRlNCB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvaG9va3MvdXNlLXN0YXRlLXdpdGgtcmVmLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsIHVzZVJlZiBhcyB1c2VSZWY0LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTMgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VTdGF0ZVdpdGhSZWYgPSAoaW5pdGlhbFN0YXRlKSA9PiB7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlU3RhdGUzKGluaXRpYWxTdGF0ZSk7XG4gIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmNChpbml0aWFsU3RhdGUpO1xuICBjb25zdCBzZXRWYWx1ZUFuZFJlZiA9IHVzZUNhbGxiYWNrMigobmV3VmFsdWUpID0+IHtcbiAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV3VmFsdWU7XG4gICAgc2V0VmFsdWUobmV3VmFsdWUpO1xuICB9LCBbXSk7XG4gIHJldHVybiBbdmFsdWUsIHNldFZhbHVlQW5kUmVmLCB2YWx1ZVJlZl07XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlLWZyYW1lLWhlaWdodC50c1xudmFyIHVzZUZyYW1lSGVpZ2h0ID0gKGFkYXB0aXZlSGVpZ2h0LCBzbGlkZXNUb1Nob3csIHNsaWRlQ291bnQpID0+IHtcbiAgY29uc3QgW3Zpc2libGVIZWlnaHRzLCBzZXRWaXNpYmxlSGVpZ2h0cywgdmlzaWJsZUhlaWdodHNSZWZdID0gdXNlU3RhdGVXaXRoUmVmKFtdKTtcbiAgY29uc3QgW2luaXRpYWxpemVkQWRhcHRpdmVIZWlnaHQsIHNldEluaXRpYWxpemVkQWRhcHRpdmVIZWlnaHRdID0gdXNlU3RhdGU0KGZhbHNlKTtcbiAgY29uc3QgaGFuZGxlVmlzaWJsZVNsaWRlSGVpZ2h0Q2hhbmdlID0gdXNlQ2FsbGJhY2szKFxuICAgIChzbGlkZUluZGV4LCBoZWlnaHQpID0+IHtcbiAgICAgIGNvbnN0IGxhdGVzdFZpc2libGVIZWlnaHRzID0gdmlzaWJsZUhlaWdodHNSZWYuY3VycmVudDtcbiAgICAgIGxldCBuZXdWaXNpYmxlSGVpZ2h0cztcbiAgICAgIGlmIChoZWlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgbmV3VmlzaWJsZUhlaWdodHMgPSBsYXRlc3RWaXNpYmxlSGVpZ2h0cy5maWx0ZXIoXG4gICAgICAgICAgKHNsaWRlSGVpZ2h0KSA9PiBzbGlkZUhlaWdodC5zbGlkZUluZGV4ICE9PSBzbGlkZUluZGV4XG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdWaXNpYmxlSGVpZ2h0cyA9IFsuLi5sYXRlc3RWaXNpYmxlSGVpZ2h0cywgeyBzbGlkZUluZGV4LCBoZWlnaHQgfV07XG4gICAgICB9XG4gICAgICBzZXRWaXNpYmxlSGVpZ2h0cyhuZXdWaXNpYmxlSGVpZ2h0cyk7XG4gICAgICBpZiAobmV3VmlzaWJsZUhlaWdodHMubGVuZ3RoID49IE1hdGgubWluKHNsaWRlQ291bnQsIE1hdGguY2VpbChzbGlkZXNUb1Nob3cpKSkge1xuICAgICAgICBzZXRJbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0KHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3NsaWRlQ291bnQsIHNldFZpc2libGVIZWlnaHRzLCBzbGlkZXNUb1Nob3csIHZpc2libGVIZWlnaHRzUmVmXVxuICApO1xuICBjb25zdCBmcmFtZUhlaWdodCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChhZGFwdGl2ZUhlaWdodCkge1xuICAgICAgaWYgKCFpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBcImF1dG9cIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IE1hdGgubWF4KFxuICAgICAgICAwLFxuICAgICAgICAuLi52aXNpYmxlSGVpZ2h0cy5tYXAoKGhlaWdodCkgPT4gaGVpZ2h0LmhlaWdodClcbiAgICAgICk7XG4gICAgICByZXR1cm4gYCR7bWF4SGVpZ2h0fXB4YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiYXV0b1wiO1xuICAgIH1cbiAgfSwgW2FkYXB0aXZlSGVpZ2h0LCBpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0LCB2aXNpYmxlSGVpZ2h0c10pO1xuICByZXR1cm4ge1xuICAgIGhhbmRsZVZpc2libGVTbGlkZUhlaWdodENoYW5nZSxcbiAgICBmcmFtZUhlaWdodCxcbiAgICBpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0XG4gIH07XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlLWZvcndhcmQtcmVmLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NSwgdXNlUmVmIGFzIHVzZVJlZjUgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VGb3J3YXJkUmVmID0gKHJlZikgPT4ge1xuICBjb25zdCB0YXJnZXRSZWYgPSB1c2VSZWY1KG51bGwpO1xuICB1c2VFZmZlY3Q1KCgpID0+IHtcbiAgICBpZiAoIXJlZilcbiAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZWYodGFyZ2V0UmVmLmN1cnJlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYuY3VycmVudCA9IHRhcmdldFJlZi5jdXJyZW50O1xuICAgIH1cbiAgfSwgW3JlZl0pO1xuICByZXR1cm4gdGFyZ2V0UmVmO1xufTtcblxuLy8gc3JjL2Nhcm91c2VsLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDcsIGpzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBDYXJvdXNlbCA9IFJlYWN0NS5mb3J3YXJkUmVmKFxuICAocmF3UHJvcHMsIHJlZikgPT4ge1xuICAgIGNvbnN0IHByb3BzID0gcmF3UHJvcHM7XG4gICAgY29uc3QgaW50ZXJuYWxDYXJvdXNlbElkID0gdXNlSWQoKTtcbiAgICBjb25zdCB7XG4gICAgICBhZGFwdGl2ZUhlaWdodCxcbiAgICAgIGFkYXB0aXZlSGVpZ2h0QW5pbWF0aW9uLFxuICAgICAgYWZ0ZXJTbGlkZSxcbiAgICAgIGFuaW1hdGlvbixcbiAgICAgIGF1dG9wbGF5LFxuICAgICAgYXV0b3BsYXlJbnRlcnZhbCxcbiAgICAgIGF1dG9wbGF5UmV2ZXJzZSxcbiAgICAgIGJlZm9yZVNsaWRlLFxuICAgICAgY2Fyb3VzZWxJZCA9IGludGVybmFsQ2Fyb3VzZWxJZCxcbiAgICAgIGNlbGxBbGlnbjogcHJvcHNDZWxsQWxpZ24sXG4gICAgICBjZWxsU3BhY2luZyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgZGlzYWJsZUFuaW1hdGlvbixcbiAgICAgIGRyYWdnaW5nOiBkZXNrdG9wRHJhZ2dpbmdFbmFibGVkLFxuICAgICAgZHJhZ1RocmVzaG9sZDogcHJvcHNEcmFnVGhyZXNob2xkLFxuICAgICAgZW5hYmxlS2V5Ym9hcmRDb250cm9scyxcbiAgICAgIGZyYW1lQXJpYUxhYmVsLFxuICAgICAga2V5Q29kZUNvbmZpZyxcbiAgICAgIGxhbmRtYXJrLFxuICAgICAgb25EcmFnLFxuICAgICAgb25EcmFnRW5kLFxuICAgICAgb25EcmFnU3RhcnQsXG4gICAgICBvblVzZXJOYXZpZ2F0aW9uLFxuICAgICAgcGF1c2VPbkhvdmVyLFxuICAgICAgcmVuZGVyQW5ub3VuY2VTbGlkZU1lc3NhZ2UsXG4gICAgICBzY3JvbGxNb2RlOiBwcm9wc1Njcm9sbE1vZGUsXG4gICAgICBzbGlkZUluZGV4LFxuICAgICAgc2xpZGVzVG9TY3JvbGw6IHByb3BzU2xpZGVzVG9TY3JvbGwsXG4gICAgICBzbGlkZXNUb1Nob3c6IHByb3BzU2xpZGVzVG9TaG93LFxuICAgICAgc2xpZGVXaWR0aCxcbiAgICAgIHNwZWVkLFxuICAgICAgc3R5bGUsXG4gICAgICBzd2lwaW5nOiBtb2JpbGVEcmFnZ2luZ0VuYWJsZWQsXG4gICAgICB0YWJiZWQsXG4gICAgICB3cmFwQXJvdW5kLFxuICAgICAgem9vbVNjYWxlXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IGZpbHRlcmVkU2xpZGVzID0gUmVhY3Q1LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCBzbGlkZUNvdW50ID0gZmlsdGVyZWRTbGlkZXMubGVuZ3RoO1xuICAgIGNvbnN0IGNlbGxBbGlnbiA9IHNsaWRlV2lkdGggfHwgcHJvcHNTbGlkZXNUb1Njcm9sbCA9PT0gXCJhdXRvXCIgPyBcImxlZnRcIiA6IHByb3BzQ2VsbEFsaWduO1xuICAgIGNvbnN0IHNjcm9sbE1vZGUgPSBwcm9wc1NsaWRlc1RvU2Nyb2xsID09PSBcImF1dG9cIiA/IFwicmVtYWluZGVyXCIgLyogcmVtYWluZGVyICovIDogcHJvcHNTY3JvbGxNb2RlO1xuICAgIGNvbnN0IFtzbGlkZUlPRW50cmllcywgc2V0U2xpZGVJT0VudHJpZXNdID0gdXNlU3RhdGU1KFxuICAgICAgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICAgICk7XG4gICAgY29uc3QgdmlzaWJsZUNvdW50ID0gQXJyYXkuZnJvbShzbGlkZUlPRW50cmllcykuZmlsdGVyKFxuICAgICAgKFssIHZpc2libGVdKSA9PiB2aXNpYmxlXG4gICAgKS5sZW5ndGg7XG4gICAgY29uc3QgW2NvbnN0YW50VmlzaWJsZUNvdW50LCBzZXRDb25zdGFudFZpc2libGVDb3VudF0gPSB1c2VTdGF0ZTUodmlzaWJsZUNvdW50KTtcbiAgICBjb25zdCBzbGlkZXNUb1Nob3cgPSBzbGlkZVdpZHRoID8gY29uc3RhbnRWaXNpYmxlQ291bnQgOiBwcm9wc1NsaWRlc1RvU2hvdztcbiAgICBjb25zdCBzbGlkZXNUb1Njcm9sbCA9IGFuaW1hdGlvbiA9PT0gXCJmYWRlXCIgPyBzbGlkZXNUb1Nob3cgOiBwcm9wc1NsaWRlc1RvU2Nyb2xsID09PSBcImF1dG9cIiA/IE1hdGgubWF4KGNvbnN0YW50VmlzaWJsZUNvdW50LCAxKSA6IHByb3BzU2xpZGVzVG9TY3JvbGw7XG4gICAgY29uc3QgW2N1cnJlbnRTbGlkZSwgc2V0Q3VycmVudFNsaWRlXSA9IHVzZVN0YXRlNShcbiAgICAgICgpID0+IGdldERlZmF1bHRTbGlkZUluZGV4KFxuICAgICAgICBzbGlkZUluZGV4LFxuICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICBzbGlkZXNUb1Nob3csXG4gICAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgICBjZWxsQWxpZ24sXG4gICAgICAgIGF1dG9wbGF5UmV2ZXJzZSxcbiAgICAgICAgc2Nyb2xsTW9kZVxuICAgICAgKVxuICAgICk7XG4gICAgY29uc3QgW3BhdXNlLCBzZXRQYXVzZV0gPSB1c2VTdGF0ZTUoZmFsc2UpO1xuICAgIGNvbnN0IFtpc0RyYWdnaW5nLCBzZXRJc0RyYWdnaW5nXSA9IHVzZVN0YXRlNShmYWxzZSk7XG4gICAgY29uc3QgW2RyYWdEaXN0YW5jZSwgc2V0RHJhZ0Rpc3RhbmNlXSA9IHVzZVN0YXRlNSgwKTtcbiAgICBjb25zdCBbYW5pbWF0aW9uRGlzdGFuY2UsIHNldEFuaW1hdGlvbkRpc3RhbmNlXSA9IHVzZVN0YXRlNSgwKTtcbiAgICBjb25zdCBbaXNBbmltYXRpbmcsIHNldElzQW5pbWF0aW5nXSA9IHVzZVN0YXRlNShmYWxzZSk7XG4gICAgY29uc3QgdXBkYXRlU2xpZGVJT0VudHJ5ID0gdXNlQ2FsbGJhY2s0KFxuICAgICAgKGlkLCBpc0Z1bGx5VmlzaWJsZSkgPT4ge1xuICAgICAgICBpZiAoISFzbGlkZUlPRW50cmllcy5nZXQoaWQpID09PSBpc0Z1bGx5VmlzaWJsZSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNldFNsaWRlSU9FbnRyaWVzKChwcmV2KSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3TWFwID0gbmV3IE1hcChwcmV2KTtcbiAgICAgICAgICBuZXdNYXAuc2V0KGlkLCBpc0Z1bGx5VmlzaWJsZSk7XG4gICAgICAgICAgcmV0dXJuIG5ld01hcDtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgW3NsaWRlSU9FbnRyaWVzXVxuICAgICk7XG4gICAgY29uc3QgcHJldkRyYWdnZWQgPSB1c2VSZWY2KGZhbHNlKTtcbiAgICB1c2VFZmZlY3Q2KCgpID0+IHtcbiAgICAgIGlmIChpc0RyYWdnaW5nKVxuICAgICAgICBwcmV2RHJhZ2dlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGlmICghKGlzRHJhZ2dpbmcgfHwgaXNBbmltYXRpbmcpKSB7XG4gICAgICAgIGlmICghcHJldkRyYWdnZWQuY3VycmVudClcbiAgICAgICAgICBzZXRDb25zdGFudFZpc2libGVDb3VudCh2aXNpYmxlQ291bnQpO1xuICAgICAgICBwcmV2RHJhZ2dlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSwgW2lzQW5pbWF0aW5nLCBpc0RyYWdnaW5nLCB2aXNpYmxlQ291bnRdKTtcbiAgICBjb25zdCBwcmV2WFBvc2l0aW9uID0gdXNlUmVmNihudWxsKTtcbiAgICBjb25zdCBwcmVEcmFnT2Zmc2V0ID0gdXNlUmVmNigwKTtcbiAgICBjb25zdCBzbGlkZXJMaXN0UmVmID0gdXNlUmVmNihudWxsKTtcbiAgICBjb25zdCBkZWZhdWx0Q2Fyb3VzZWxSZWYgPSB1c2VSZWY2KG51bGwpO1xuICAgIGNvbnN0IGF1dG9wbGF5VGltZW91dCA9IHVzZVJlZjYoKTtcbiAgICBjb25zdCBhdXRvcGxheUxhc3RUcmlnZ2VyZWRSZWYgPSB1c2VSZWY2KG51bGwpO1xuICAgIGNvbnN0IGlzTW91bnRlZCA9IHVzZVJlZjYodHJ1ZSk7XG4gICAgY29uc3Qgc2V0U2xpZGVyTGlzdFJlZiA9IHVzZUNhbGxiYWNrNCgobm9kZSkgPT4ge1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgbm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiLnNsaWRlci1saXN0IGltZ1wiKS5mb3JFYWNoKChlbCkgPT4gZWwuc2V0QXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIsIFwiZmFsc2VcIikpO1xuICAgICAgfVxuICAgICAgc2xpZGVyTGlzdFJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0NigoKSA9PiB7XG4gICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgZm9yd2FyZGVkUmVmID0gdXNlRm9yd2FyZFJlZihyZWYpO1xuICAgIGNvbnN0IGNhcm91c2VsUmVmID0gZm9yd2FyZGVkUmVmIHx8IGRlZmF1bHRDYXJvdXNlbFJlZjtcbiAgICBjb25zdCBnb1RvU2xpZGUgPSB1c2VDYWxsYmFjazQoXG4gICAgICAodGFyZ2V0U2xpZGVVbmJvdW5kZWQpID0+IHtcbiAgICAgICAgaWYgKCFzbGlkZXJMaXN0UmVmLmN1cnJlbnQgfHwgIWNhcm91c2VsUmVmLmN1cnJlbnQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB0YXJnZXRTbGlkZUJvdW5kZWQgPSBnZXRCb3VuZGVkSW5kZXgoXG4gICAgICAgICAgdGFyZ2V0U2xpZGVVbmJvdW5kZWQsXG4gICAgICAgICAgc2xpZGVDb3VudFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBzbGlkZUNoYW5nZWQgPSB0YXJnZXRTbGlkZVVuYm91bmRlZCAhPT0gY3VycmVudFNsaWRlO1xuICAgICAgICBzbGlkZUNoYW5nZWQgJiYgYmVmb3JlU2xpZGUoY3VycmVudFNsaWRlLCB0YXJnZXRTbGlkZUJvdW5kZWQpO1xuICAgICAgICBjb25zdCBjdXJyZW50T2Zmc2V0ID0gc2xpZGVyTGlzdFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBjYXJvdXNlbFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgIGNvbnN0IHNsaWRlcldpZHRoID0gc2xpZGVyTGlzdFJlZi5jdXJyZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICBsZXQgdGFyZ2V0T2Zmc2V0ID0gZ2V0UGVyY2VudE9mZnNldEZvclNsaWRlKFxuICAgICAgICAgIHRhcmdldFNsaWRlQm91bmRlZCxcbiAgICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgICAgICBjZWxsQWxpZ24sXG4gICAgICAgICAgd3JhcEFyb3VuZFxuICAgICAgICApIC8gMTAwICogc2xpZGVyV2lkdGg7XG4gICAgICAgIGlmICh3cmFwQXJvdW5kKSB7XG4gICAgICAgICAgY29uc3Qgc2xpZGVTZXRXaWR0aCA9IHNsaWRlcldpZHRoIC8gMztcbiAgICAgICAgICBpZiAodGFyZ2V0U2xpZGVVbmJvdW5kZWQgPCAwKSB7XG4gICAgICAgICAgICB0YXJnZXRPZmZzZXQgKz0gc2xpZGVTZXRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRhcmdldFNsaWRlVW5ib3VuZGVkID49IHNsaWRlQ291bnQpIHtcbiAgICAgICAgICAgIHRhcmdldE9mZnNldCAtPSBzbGlkZVNldFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRBbmltYXRpb25EaXN0YW5jZSh0YXJnZXRPZmZzZXQgLSBjdXJyZW50T2Zmc2V0KTtcbiAgICAgICAgaWYgKHNsaWRlQ2hhbmdlZCkge1xuICAgICAgICAgIHNldEN1cnJlbnRTbGlkZSh0YXJnZXRTbGlkZUJvdW5kZWQpO1xuICAgICAgICAgIGNvbnN0IG1zVG9FbmRPZkFuaW1hdGlvbiA9ICFkaXNhYmxlQW5pbWF0aW9uID8gc3BlZWQgfHwgNTAwIDogNDA7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzTW91bnRlZC5jdXJyZW50KVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBhZnRlclNsaWRlKHRhcmdldFNsaWRlQm91bmRlZCk7XG4gICAgICAgICAgfSwgbXNUb0VuZE9mQW5pbWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtcbiAgICAgICAgYWZ0ZXJTbGlkZSxcbiAgICAgICAgYmVmb3JlU2xpZGUsXG4gICAgICAgIGNhcm91c2VsUmVmLFxuICAgICAgICBjZWxsQWxpZ24sXG4gICAgICAgIGN1cnJlbnRTbGlkZSxcbiAgICAgICAgZGlzYWJsZUFuaW1hdGlvbixcbiAgICAgICAgc3BlZWQsXG4gICAgICAgIHNsaWRlQ291bnQsXG4gICAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgICAgd3JhcEFyb3VuZFxuICAgICAgXVxuICAgICk7XG4gICAgY29uc3QgbmV4dFNsaWRlID0gdXNlQ2FsbGJhY2s0KCgpID0+IHtcbiAgICAgIGNvbnN0IG5leHRTbGlkZUluZGV4ID0gZ2V0TmV4dE1vdmVJbmRleChcbiAgICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgICAgd3JhcEFyb3VuZCxcbiAgICAgICAgY3VycmVudFNsaWRlLFxuICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICBzbGlkZXNUb1Njcm9sbCxcbiAgICAgICAgc2xpZGVzVG9TaG93LFxuICAgICAgICBjZWxsQWxpZ25cbiAgICAgICk7XG4gICAgICBpZiAoY3VycmVudFNsaWRlICE9PSBuZXh0U2xpZGVJbmRleCkge1xuICAgICAgICBnb1RvU2xpZGUobmV4dFNsaWRlSW5kZXgpO1xuICAgICAgfVxuICAgIH0sIFtcbiAgICAgIGNlbGxBbGlnbixcbiAgICAgIGN1cnJlbnRTbGlkZSxcbiAgICAgIGdvVG9TbGlkZSxcbiAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgIHNsaWRlQ291bnQsXG4gICAgICBzbGlkZXNUb1Nob3csXG4gICAgICB3cmFwQXJvdW5kXG4gICAgXSk7XG4gICAgY29uc3QgcHJldlNsaWRlID0gdXNlQ2FsbGJhY2s0KCgpID0+IHtcbiAgICAgIGNvbnN0IHByZXZTbGlkZUluZGV4ID0gZ2V0UHJldk1vdmVJbmRleChcbiAgICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgICAgd3JhcEFyb3VuZCxcbiAgICAgICAgY3VycmVudFNsaWRlLFxuICAgICAgICBzbGlkZXNUb1Njcm9sbCxcbiAgICAgICAgc2xpZGVzVG9TaG93LFxuICAgICAgICBjZWxsQWxpZ25cbiAgICAgICk7XG4gICAgICBpZiAoY3VycmVudFNsaWRlICE9PSBwcmV2U2xpZGVJbmRleCkge1xuICAgICAgICBnb1RvU2xpZGUocHJldlNsaWRlSW5kZXgpO1xuICAgICAgfVxuICAgIH0sIFtcbiAgICAgIGNlbGxBbGlnbixcbiAgICAgIGN1cnJlbnRTbGlkZSxcbiAgICAgIGdvVG9TbGlkZSxcbiAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgIHdyYXBBcm91bmRcbiAgICBdKTtcbiAgICBjb25zdCBwcmV2TW92ZWRUb1NsaWRlSW5kZXggPSB1c2VSZWY2KHNsaWRlSW5kZXgpO1xuICAgIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgICAgaWYgKHNsaWRlSW5kZXggIT09IHZvaWQgMCAmJiBzbGlkZUluZGV4ICE9PSBwcmV2TW92ZWRUb1NsaWRlSW5kZXguY3VycmVudCAmJiAhYXV0b3BsYXlSZXZlcnNlKSB7XG4gICAgICAgIGdvVG9TbGlkZShzbGlkZUluZGV4KTtcbiAgICAgICAgcHJldk1vdmVkVG9TbGlkZUluZGV4LmN1cnJlbnQgPSBzbGlkZUluZGV4O1xuICAgICAgfVxuICAgIH0sIFtzbGlkZUluZGV4LCBhdXRvcGxheVJldmVyc2UsIGdvVG9TbGlkZV0pO1xuICAgIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgICAgbGV0IHBhdXNlU3RhcnRlZCA9IG51bGw7XG4gICAgICBpZiAocGF1c2UpIHtcbiAgICAgICAgcGF1c2VTdGFydGVkID0gRGF0ZS5ub3coKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChwYXVzZVN0YXJ0ZWQgIT09IG51bGwgJiYgYXV0b3BsYXlMYXN0VHJpZ2dlcmVkUmVmLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBhdXRvcGxheUxhc3RUcmlnZ2VyZWRSZWYuY3VycmVudCArPSBEYXRlLm5vdygpIC0gcGF1c2VTdGFydGVkO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIFtwYXVzZV0pO1xuICAgIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgICAgaWYgKGF1dG9wbGF5ICYmICFwYXVzZSkge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFRpbWVvdXRNcyA9IGF1dG9wbGF5TGFzdFRyaWdnZXJlZFJlZi5jdXJyZW50ICE9PSBudWxsID8gYXV0b3BsYXlJbnRlcnZhbCAtIChEYXRlLm5vdygpIC0gYXV0b3BsYXlMYXN0VHJpZ2dlcmVkUmVmLmN1cnJlbnQpIDogYXV0b3BsYXlJbnRlcnZhbDtcbiAgICAgICAgYXV0b3BsYXlUaW1lb3V0LmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBhdXRvcGxheUxhc3RUcmlnZ2VyZWRSZWYuY3VycmVudCA9IERhdGUubm93KCk7XG4gICAgICAgICAgaWYgKGF1dG9wbGF5UmV2ZXJzZSkge1xuICAgICAgICAgICAgcHJldlNsaWRlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHRTbGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgYWRqdXN0ZWRUaW1lb3V0TXMpO1xuICAgICAgfVxuICAgICAgaWYgKGF1dG9wbGF5ICYmIHBhdXNlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhdXRvcGxheVRpbWVvdXQuY3VycmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQoYXV0b3BsYXlUaW1lb3V0LmN1cnJlbnQpO1xuICAgICAgfTtcbiAgICB9LCBbXG4gICAgICBwYXVzZSxcbiAgICAgIGF1dG9wbGF5LFxuICAgICAgYXV0b3BsYXlJbnRlcnZhbCxcbiAgICAgIGF1dG9wbGF5UmV2ZXJzZSxcbiAgICAgIHByZXZTbGlkZSxcbiAgICAgIG5leHRTbGlkZVxuICAgIF0pO1xuICAgIGNvbnN0IG9uS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgbGV0IGtleUNvbW1hbmQgPSBudWxsO1xuICAgICAgT2JqZWN0LmtleXMoa2V5Q29kZUNvbmZpZykuZm9yRWFjaChcbiAgICAgICAgKGNvbW1hbmQpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgaWYgKChfYSA9IGtleUNvZGVDb25maWdbY29tbWFuZF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhldmVudC5rZXlDb2RlKSkge1xuICAgICAgICAgICAga2V5Q29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaWYgKGtleUNvbW1hbmQgPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHN3aXRjaCAoa2V5Q29tbWFuZCkge1xuICAgICAgICBjYXNlIFwibmV4dFNsaWRlXCI6XG4gICAgICAgICAgb25Vc2VyTmF2aWdhdGlvbihldmVudCk7XG4gICAgICAgICAgbmV4dFNsaWRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwcmV2aW91c1NsaWRlXCI6XG4gICAgICAgICAgb25Vc2VyTmF2aWdhdGlvbihldmVudCk7XG4gICAgICAgICAgcHJldlNsaWRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmaXJzdFNsaWRlXCI6XG4gICAgICAgIGNhc2UgXCJsYXN0U2xpZGVcIjoge1xuICAgICAgICAgIG9uVXNlck5hdmlnYXRpb24oZXZlbnQpO1xuICAgICAgICAgIGNvbnN0IGRvdEluZGljZXMgPSBnZXREb3RJbmRleGVzKFxuICAgICAgICAgICAgc2xpZGVDb3VudCxcbiAgICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgICAgICAgIHdyYXBBcm91bmQsXG4gICAgICAgICAgICBjZWxsQWxpZ25cbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChrZXlDb21tYW5kID09PSBcImZpcnN0U2xpZGVcIikge1xuICAgICAgICAgICAgZ29Ub1NsaWRlKGRvdEluZGljZXNbMF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnb1RvU2xpZGUoZG90SW5kaWNlc1tkb3RJbmRpY2VzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInBhdXNlXCI6XG4gICAgICAgICAgc2V0UGF1c2UoKHApID0+ICFwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRyYWdQb3NpdGlvbnMgPSB1c2VSZWY2KFtdKTtcbiAgICBjb25zdCBoYW5kbGVEcmFnRW5kID0gKGUpID0+IHtcbiAgICAgIGlmICghaXNEcmFnZ2luZyB8fCAhY2Fyb3VzZWxSZWYuY3VycmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgc2V0SXNEcmFnZ2luZyhmYWxzZSk7XG4gICAgICBsZXQgZGlzdGFuY2VGcm9tSW5lcnRpYSA9IDA7XG4gICAgICBpZiAoZHJhZ1Bvc2l0aW9ucy5jdXJyZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRNb3ZlID0gZHJhZ1Bvc2l0aW9ucy5jdXJyZW50WzBdO1xuICAgICAgICBjb25zdCBlbmRNb3ZlID0gZHJhZ1Bvc2l0aW9ucy5jdXJyZW50W2RyYWdQb3NpdGlvbnMuY3VycmVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgdGltZU9mZnNldCA9IGVuZE1vdmUudGltZSAtIHN0YXJ0TW92ZS50aW1lO1xuICAgICAgICBjb25zdCBnb29kSW5lcnRpYUZlZWxDb25zdGFudCA9IDk7XG4gICAgICAgIGNvbnN0IGdvb2RGcmljdGlvbkZlZWxDb25zdGFudCA9IDAuOTI7XG4gICAgICAgIGNvbnN0IGluaXRpYWxWZWxvY2l0eSA9IGdvb2RJbmVydGlhRmVlbENvbnN0YW50ICogTWF0aC5hYnMoKGVuZE1vdmUucG9zIC0gc3RhcnRNb3ZlLnBvcykgLyB0aW1lT2Zmc2V0KTtcbiAgICAgICAgbGV0IHZlbG9jaXR5ID0gaW5pdGlhbFZlbG9jaXR5O1xuICAgICAgICB3aGlsZSAoTWF0aC5hYnModmVsb2NpdHkpID4gMSkge1xuICAgICAgICAgIGRpc3RhbmNlRnJvbUluZXJ0aWEgKz0gdmVsb2NpdHk7XG4gICAgICAgICAgdmVsb2NpdHkgKj0gZ29vZEZyaWN0aW9uRmVlbENvbnN0YW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkcmFnUG9zaXRpb25zLmN1cnJlbnQgPSBbXTtcbiAgICAgIGNvbnN0IGFkanVzdGVkRHJhZ0Rpc3RhbmNlID0gTWF0aC5hYnMoZHJhZ0Rpc3RhbmNlKSArIE1hdGguYWJzKGRpc3RhbmNlRnJvbUluZXJ0aWEpO1xuICAgICAgb25EcmFnRW5kKGUpO1xuICAgICAgcHJldlhQb3NpdGlvbi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHNldERyYWdEaXN0YW5jZSgwKTtcbiAgICAgIGNvbnN0IG9uZVNjcm9sbFdpZHRoID0gY2Fyb3VzZWxSZWYuY3VycmVudC5vZmZzZXRXaWR0aCAqIE1hdGgubWluKDEsIHNsaWRlc1RvU2Nyb2xsIC8gc2xpZGVzVG9TaG93KTtcbiAgICAgIGNvbnN0IGRyYWdUaHJlc2hvbGQgPSBvbmVTY3JvbGxXaWR0aCAqIHByb3BzRHJhZ1RocmVzaG9sZDtcbiAgICAgIGlmIChhZGp1c3RlZERyYWdEaXN0YW5jZSA8IGRyYWdUaHJlc2hvbGQpIHtcbiAgICAgICAgZ29Ub1NsaWRlKGN1cnJlbnRTbGlkZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbk1haW50YWluVmlzdWFsQ29udGludWl0eSA9IHNsaWRlc1RvU2hvdyA+PSAyICogc2xpZGVzVG9TY3JvbGw7XG4gICAgICBjb25zdCB0aW1lc1RvTW92ZSA9IGNhbk1haW50YWluVmlzdWFsQ29udGludWl0eSA/IDEgKyBNYXRoLmZsb29yKChhZGp1c3RlZERyYWdEaXN0YW5jZSAtIGRyYWdUaHJlc2hvbGQpIC8gb25lU2Nyb2xsV2lkdGgpIDogMTtcbiAgICAgIGxldCBuZXh0U2xpZGVJbmRleCA9IGN1cnJlbnRTbGlkZTtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aW1lc1RvTW92ZTsgaW5kZXggKz0gMSkge1xuICAgICAgICBpZiAoZHJhZ0Rpc3RhbmNlID4gMCkge1xuICAgICAgICAgIG5leHRTbGlkZUluZGV4ID0gZ2V0TmV4dE1vdmVJbmRleChcbiAgICAgICAgICAgIHNjcm9sbE1vZGUsXG4gICAgICAgICAgICB3cmFwQXJvdW5kLFxuICAgICAgICAgICAgbmV4dFNsaWRlSW5kZXgsXG4gICAgICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICAgICAgc2xpZGVzVG9TY3JvbGwsXG4gICAgICAgICAgICBzbGlkZXNUb1Nob3csXG4gICAgICAgICAgICBjZWxsQWxpZ25cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRTbGlkZUluZGV4ID0gZ2V0UHJldk1vdmVJbmRleChcbiAgICAgICAgICAgIHNjcm9sbE1vZGUsXG4gICAgICAgICAgICB3cmFwQXJvdW5kLFxuICAgICAgICAgICAgbmV4dFNsaWRlSW5kZXgsXG4gICAgICAgICAgICBzbGlkZXNUb1Njcm9sbCxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgICAgICAgIGNlbGxBbGlnblxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXh0U2xpZGVJbmRleCAhPT0gY3VycmVudFNsaWRlKSB7XG4gICAgICAgIG9uVXNlck5hdmlnYXRpb24oZSk7XG4gICAgICB9XG4gICAgICBnb1RvU2xpZGUobmV4dFNsaWRlSW5kZXgpO1xuICAgIH07XG4gICAgY29uc3Qgb25Ub3VjaFN0YXJ0ID0gdXNlQ2FsbGJhY2s0KFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgaWYgKCFtb2JpbGVEcmFnZ2luZ0VuYWJsZWQgfHwgIXNsaWRlckxpc3RSZWYuY3VycmVudCB8fCAhY2Fyb3VzZWxSZWYuY3VycmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRJc0RyYWdnaW5nKHRydWUpO1xuICAgICAgICBwcmVEcmFnT2Zmc2V0LmN1cnJlbnQgPSBzbGlkZXJMaXN0UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIGNhcm91c2VsUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICAgICAgb25EcmFnU3RhcnQoZSk7XG4gICAgICB9LFxuICAgICAgW2Nhcm91c2VsUmVmLCBvbkRyYWdTdGFydCwgbW9iaWxlRHJhZ2dpbmdFbmFibGVkXVxuICAgICk7XG4gICAgY29uc3QgaGFuZGxlUG9pbnRlck1vdmUgPSB1c2VDYWxsYmFjazQoXG4gICAgICAoeFBvc2l0aW9uKSA9PiB7XG4gICAgICAgIGlmICghaXNEcmFnZ2luZylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGlzRmlyc3RNb3ZlID0gcHJldlhQb3NpdGlvbi5jdXJyZW50ID09PSBudWxsO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHByZXZYUG9zaXRpb24uY3VycmVudCAhPT0gbnVsbCA/IHhQb3NpdGlvbiAtIHByZXZYUG9zaXRpb24uY3VycmVudCA6IDA7XG4gICAgICAgIGNvbnN0IG5leHREcmFnRGlzdGFuY2UgPSBkcmFnRGlzdGFuY2UgKyBkZWx0YTtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKGRyYWdQb3NpdGlvbnMuY3VycmVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKG5vdyAtIGRyYWdQb3NpdGlvbnMuY3VycmVudFswXS50aW1lIDw9IDEwMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRyYWdQb3NpdGlvbnMuY3VycmVudC5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGRyYWdQb3NpdGlvbnMuY3VycmVudC5wdXNoKHsgcG9zOiBuZXh0RHJhZ0Rpc3RhbmNlLCB0aW1lOiBub3cgfSk7XG4gICAgICAgIGlmICghaXNGaXJzdE1vdmUpIHtcbiAgICAgICAgICBzZXREcmFnRGlzdGFuY2UobmV4dERyYWdEaXN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldlhQb3NpdGlvbi5jdXJyZW50ID0geFBvc2l0aW9uO1xuICAgICAgfSxcbiAgICAgIFtpc0RyYWdnaW5nLCBkcmFnRGlzdGFuY2VdXG4gICAgKTtcbiAgICBjb25zdCBvblRvdWNoTW92ZSA9IHVzZUNhbGxiYWNrNChcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGlmICghaXNEcmFnZ2luZyB8fCAhY2Fyb3VzZWxSZWYuY3VycmVudClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIG9uRHJhZ1N0YXJ0KGUpO1xuICAgICAgICBjb25zdCBtb3ZlVmFsdWUgPSBjYXJvdXNlbFJlZi5jdXJyZW50Lm9mZnNldFdpZHRoIC0gZS50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICBoYW5kbGVQb2ludGVyTW92ZShtb3ZlVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIFtpc0RyYWdnaW5nLCBjYXJvdXNlbFJlZiwgaGFuZGxlUG9pbnRlck1vdmUsIG9uRHJhZ1N0YXJ0XVxuICAgICk7XG4gICAgY29uc3Qgb25Nb3VzZURvd24gPSB1c2VDYWxsYmFjazQoXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBpZiAoIWRlc2t0b3BEcmFnZ2luZ0VuYWJsZWQgfHwgIXNsaWRlckxpc3RSZWYuY3VycmVudCB8fCAhY2Fyb3VzZWxSZWYuY3VycmVudClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNldElzRHJhZ2dpbmcodHJ1ZSk7XG4gICAgICAgIHByZURyYWdPZmZzZXQuY3VycmVudCA9IHNsaWRlckxpc3RSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gY2Fyb3VzZWxSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgICAgICBvbkRyYWdTdGFydChlKTtcbiAgICAgIH0sXG4gICAgICBbY2Fyb3VzZWxSZWYsIGRlc2t0b3BEcmFnZ2luZ0VuYWJsZWQsIG9uRHJhZ1N0YXJ0XVxuICAgICk7XG4gICAgY29uc3Qgb25Nb3VzZU1vdmUgPSB1c2VDYWxsYmFjazQoXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBpZiAoIWlzRHJhZ2dpbmcgfHwgIWNhcm91c2VsUmVmLmN1cnJlbnQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvbkRyYWcoZSk7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBlLmNsaWVudFggLSBjYXJvdXNlbFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgIGNvbnN0IG1vdmVWYWx1ZSA9IGNhcm91c2VsUmVmLmN1cnJlbnQub2Zmc2V0V2lkdGggLSBvZmZzZXRYO1xuICAgICAgICBoYW5kbGVQb2ludGVyTW92ZShtb3ZlVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIFtjYXJvdXNlbFJlZiwgaXNEcmFnZ2luZywgaGFuZGxlUG9pbnRlck1vdmUsIG9uRHJhZ11cbiAgICApO1xuICAgIGNvbnN0IG9uTW91c2VVcCA9IChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBoYW5kbGVEcmFnRW5kKGUpO1xuICAgIH07XG4gICAgY29uc3Qgb25Nb3VzZUVudGVyID0gdXNlQ2FsbGJhY2s0KCgpID0+IHtcbiAgICAgIGlmIChwYXVzZU9uSG92ZXIpIHtcbiAgICAgICAgc2V0UGF1c2UodHJ1ZSk7XG4gICAgICB9XG4gICAgfSwgW3BhdXNlT25Ib3Zlcl0pO1xuICAgIGNvbnN0IG9uTW91c2VMZWF2ZSA9IHVzZUNhbGxiYWNrNCgoKSA9PiB7XG4gICAgICBpZiAocGF1c2VPbkhvdmVyKSB7XG4gICAgICAgIHNldFBhdXNlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LCBbcGF1c2VPbkhvdmVyXSk7XG4gICAgY29uc3Qge1xuICAgICAgZnJhbWVIZWlnaHQsXG4gICAgICBoYW5kbGVWaXNpYmxlU2xpZGVIZWlnaHRDaGFuZ2UsXG4gICAgICBpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0XG4gICAgfSA9IHVzZUZyYW1lSGVpZ2h0KGFkYXB0aXZlSGVpZ2h0LCBzbGlkZXNUb1Nob3csIHNsaWRlQ291bnQpO1xuICAgIGNvbnN0IHJlbmRlclNsaWRlcyA9ICh0eXBlT2ZTbGlkZSkgPT4ge1xuICAgICAgY29uc3Qgc2xpZGVzID0gZmlsdGVyZWRTbGlkZXMubWFwKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g3KFxuICAgICAgICAgIHNsaWRlX2RlZmF1bHQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQ6IGAke3R5cGVPZlNsaWRlfS0ke2luZGV4fWAsXG4gICAgICAgICAgICBjYXJvdXNlbElkLFxuICAgICAgICAgICAgY291bnQ6IHNsaWRlQ291bnQsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIGlzQ3VycmVudFNsaWRlOiBjdXJyZW50U2xpZGUgPT09IGluZGV4LFxuICAgICAgICAgICAgdHlwZU9mU2xpZGUsXG4gICAgICAgICAgICB3cmFwQXJvdW5kLFxuICAgICAgICAgICAgY2VsbFNwYWNpbmcsXG4gICAgICAgICAgICBhbmltYXRpb24sXG4gICAgICAgICAgICBzcGVlZCxcbiAgICAgICAgICAgIHpvb21TY2FsZSxcbiAgICAgICAgICAgIG9uVmlzaWJsZVNsaWRlSGVpZ2h0Q2hhbmdlOiBoYW5kbGVWaXNpYmxlU2xpZGVIZWlnaHRDaGFuZ2UsXG4gICAgICAgICAgICBzbGlkZVdpZHRoLFxuICAgICAgICAgICAgdXBkYXRlSU9FbnRyeTogdXBkYXRlU2xpZGVJT0VudHJ5LFxuICAgICAgICAgICAgYWRhcHRpdmVIZWlnaHQsXG4gICAgICAgICAgICBpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0LFxuICAgICAgICAgICAgY2Fyb3VzZWxSZWYsXG4gICAgICAgICAgICB0YWJiZWQsXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGAke3R5cGVPZlNsaWRlfS0ke2luZGV4fWBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNsaWRlcztcbiAgICB9O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJzbGlkZXItY29udGFpbmVyXCIsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIlxuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlRW50ZXIsXG4gICAgICAgIG9uTW91c2VMZWF2ZSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IGZyYW1lQXJpYUxhYmVsLFxuICAgICAgICByb2xlOiBsYW5kbWFyayA/IFwicmVnaW9uXCIgOiBcImdyb3VwXCIsXG4gICAgICAgIFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogXCJjYXJvdXNlbFwiLFxuICAgICAgICBpZDogY2Fyb3VzZWxJZCxcbiAgICAgICAgXCJkYXRhLXRlc3RpZFwiOiBjYXJvdXNlbElkLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g3KFxuICAgICAgICAgICAgYW5ub3VuY2Vfc2xpZGVfZGVmYXVsdCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYXJpYUxpdmU6IGF1dG9wbGF5ICYmICFwYXVzZSA/IFwib2ZmXCIgOiBcInBvbGl0ZVwiLFxuICAgICAgICAgICAgICBtZXNzYWdlOiByZW5kZXJBbm5vdW5jZVNsaWRlTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgY3VycmVudFNsaWRlLFxuICAgICAgICAgICAgICAgIGNvdW50OiBzbGlkZUNvdW50XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICBjb250cm9sc19kZWZhdWx0KFxuICAgICAgICAgICAgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpLCB7IGNhcm91c2VsSWQgfSksXG4gICAgICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICAgICAgY3VycmVudFNsaWRlLFxuICAgICAgICAgICAgZ29Ub1NsaWRlLFxuICAgICAgICAgICAgbmV4dFNsaWRlLFxuICAgICAgICAgICAgcHJldlNsaWRlLFxuICAgICAgICAgICAgc2xpZGVzVG9TY3JvbGxcbiAgICAgICAgICApLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g3KFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBbXCJzbGlkZXItZnJhbWVcIiwgY2xhc3NOYW1lIHx8IFwiXCJdLmpvaW4oXCIgXCIpLnRyaW0oKSxcbiAgICAgICAgICAgICAgc3R5bGU6IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgICAgICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgICAgICAgICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICB0b3VjaEFjdGlvbjogXCJwYW4teVwiLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZnJhbWVIZWlnaHQsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogYWRhcHRpdmVIZWlnaHRBbmltYXRpb24gPyBcImhlaWdodCAzMDBtcyBlYXNlLWluLW91dFwiIDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIHdpbGxDaGFuZ2U6IFwiaGVpZ2h0XCIsXG4gICAgICAgICAgICAgICAgdXNlclNlbGVjdDogXCJub25lXCJcbiAgICAgICAgICAgICAgfSwgc3R5bGUpLFxuICAgICAgICAgICAgICB0YWJJbmRleDogZW5hYmxlS2V5Ym9hcmRDb250cm9scyA/IDAgOiAtMSxcbiAgICAgICAgICAgICAgb25LZXlEb3duOiBlbmFibGVLZXlib2FyZENvbnRyb2xzID8gb25LZXlEb3duIDogdm9pZCAwLFxuICAgICAgICAgICAgICByZWY6IGNhcm91c2VsUmVmLFxuICAgICAgICAgICAgICBvbk1vdXNlVXAsXG4gICAgICAgICAgICAgIG9uTW91c2VEb3duLFxuICAgICAgICAgICAgICBvbk1vdXNlTW92ZSxcbiAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlOiBvbk1vdXNlVXAsXG4gICAgICAgICAgICAgIG9uVG91Y2hTdGFydCxcbiAgICAgICAgICAgICAgb25Ub3VjaEVuZDogaGFuZGxlRHJhZ0VuZCxcbiAgICAgICAgICAgICAgb25Ub3VjaE1vdmUsXG4gICAgICAgICAgICAgIGlkOiBgJHtjYXJvdXNlbElkfS1zbGlkZXItZnJhbWVgLFxuICAgICAgICAgICAgICBcImRhdGEtdGVzdGlkXCI6IGAke2Nhcm91c2VsSWR9LXNsaWRlci1mcmFtZWAsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4cyhcbiAgICAgICAgICAgICAgICBTbGlkZXJMaXN0LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkRpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgY2VsbEFsaWduLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFNsaWRlLFxuICAgICAgICAgICAgICAgICAgZGlzYWJsZUVkZ2VTd2lwaW5nOiBwcm9wcy5kaXNhYmxlRWRnZVN3aXBpbmcsXG4gICAgICAgICAgICAgICAgICBkcmFnZ2VkT2Zmc2V0OiBwcmVEcmFnT2Zmc2V0LmN1cnJlbnQgLSBkcmFnRGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICBkaXNhYmxlQW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgICAgZWFzaW5nOiBwcm9wcy5lYXNpbmcsXG4gICAgICAgICAgICAgICAgICBlZGdlRWFzaW5nOiBwcm9wcy5lZGdlRWFzaW5nLFxuICAgICAgICAgICAgICAgICAgaXNEcmFnZ2luZyxcbiAgICAgICAgICAgICAgICAgIHJlZjogc2V0U2xpZGVyTGlzdFJlZixcbiAgICAgICAgICAgICAgICAgIHNjcm9sbE1vZGUsXG4gICAgICAgICAgICAgICAgICBhbmltYXRpb24sXG4gICAgICAgICAgICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICAgICAgICAgICAgc2xpZGVzVG9TY3JvbGwsXG4gICAgICAgICAgICAgICAgICBzbGlkZXNUb1Nob3csXG4gICAgICAgICAgICAgICAgICBzcGVlZCxcbiAgICAgICAgICAgICAgICAgIHNsaWRlV2lkdGgsXG4gICAgICAgICAgICAgICAgICB3cmFwQXJvdW5kLFxuICAgICAgICAgICAgICAgICAgc2V0SXNBbmltYXRpbmcsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICB3cmFwQXJvdW5kID8gcmVuZGVyU2xpZGVzKFwicHJldi1jbG9uZWRcIikgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJTbGlkZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgd3JhcEFyb3VuZCA/IHJlbmRlclNsaWRlcyhcIm5leHQtY2xvbmVkXCIpIDogbnVsbFxuICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgXVxuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5DYXJvdXNlbC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0X2Nhcm91c2VsX3Byb3BzX2RlZmF1bHQ7XG5DYXJvdXNlbC5kaXNwbGF5TmFtZSA9IFwiQ2Fyb3VzZWxcIjtcbmV4cG9ydCB7XG4gIEFsaWdubWVudCxcbiAgRGlyZWN0aW9ucyxcbiAgTmV4dEJ1dHRvbixcbiAgUGFnaW5nRG90cyxcbiAgUG9zaXRpb25zLFxuICBQcmV2aW91c0J1dHRvbixcbiAgU2Nyb2xsTW9kZSxcbiAgQ2Fyb3VzZWwgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nuka-carousel/dist/index.mjs\n");

/***/ })

};
;